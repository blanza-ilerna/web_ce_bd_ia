<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Pseudoc√≥digo en IA y Big Data - Lenguaje intermedio para dise√±ar algoritmos - iLERNA">
    <meta name="keywords"
        content="Pseudoc√≥digo, Algoritmos, IA, Big Data, K-Means, MapReduce, √Årboles de Decisi√≥n, iLERNA">
    <meta name="author" content="iLERNA">
    <title>Pseudoc√≥digo en IA y Big Data | iLERNA</title>
    <link rel="stylesheet" href="../css/lecciones.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="header-container">
                <div class="logo-container">
                    <a href="../index.html">
                        <img src="../img/logo-ilerna.svg" alt="Logo iLERNA">
                    </a>
                    <div class="logo-text">
                        iLERNA
                        <span>Curso de Especializaci√≥n en IA y Big Data</span>
                    </div>
                </div>
                <div class="breadcrumb">
                    <a href="../index.html">Inicio</a> ‚Ä∫
                    <a href="index.html">Programaci√≥n IA</a> ‚Ä∫
                    <span>Pseudoc√≥digo</span>
                </div>
            </div>
            <h1 class="text-center">¬øQu√© es el pseudoc√≥digo?</h1>
            <p class="subtitle text-center">Lenguaje intermedio para dise√±ar algoritmos en IA y Big Data</p>
        </header>

        <main>

            <!-- Introducci√≥n -->
            <section class="section">
                <h2>1. Introducci√≥n al Pseudoc√≥digo</h2>
                <p>El <strong>pseudoc√≥digo</strong> es una herramienta fundamental en el desarrollo de software, especialmente en √°reas complejas como la Inteligencia Artificial (IA) y Big Data. Se trata de un <strong>lenguaje intermedio entre el lenguaje natural y los lenguajes de programaci√≥n</strong>, dise√±ado para expresar algoritmos de forma clara y estructurada sin depender de la sintaxis espec√≠fica de un lenguaje.</p>

                <div class="highlight-box">
                    <h4>¬øPor qu√© es importante?</h4>
                    <p>En proyectos de IA y Big Data, los algoritmos pueden ser extremadamente complejos. El pseudoc√≥digo permite a los equipos dise√±ar, comunicar y validar soluciones antes de invertir tiempo en la implementaci√≥n.</p>
                </div>

                <h3>Ventajas del Pseudoc√≥digo</h3>
                <div class="feature-cards">
                    <div class="feature-card">
                        <h4>üéØ Claridad</h4>
                        <p>Facilita la comprensi√≥n del flujo l√≥gico sin la complejidad sint√°ctica de un lenguaje de programaci√≥n.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üåê Independencia</h4>
                        <p>No est√° ligado a un lenguaje espec√≠fico, lo que permite adaptar el algoritmo a diferentes tecnolog√≠as.</p>
                    </div>
                    <div class="feature-card">
                        <h4>ü§ù Comunicaci√≥n</h4>
                        <p>Sirve como puente entre analistas, dise√±adores y programadores en equipos multidisciplinares.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üîç Detecci√≥n de Errores</h4>
                        <p>Permite identificar problemas l√≥gicos antes de la codificaci√≥n, ahorrando tiempo y recursos.</p>
                    </div>
                </div>
            </section>

            <!-- Sintaxis B√°sica -->
            <section class="section">
                <h2>2. Sintaxis B√°sica del Pseudoc√≥digo</h2>

                <h3>2.1. Variables y Tipos de Datos</h3>
                <p>Las variables se declaran indicando su tipo y nombre. Los tipos comunes incluyen:</p>
                <ul>
                    <li><code>entero</code>: N√∫meros enteros (ej. 5, -10, 1000)</li>
                    <li><code>real</code>: N√∫meros con decimales (ej. 3.14, -0.5)</li>
                    <li><code>cadena</code>: Texto (ej. "Hola", "usuario@email.com")</li>
                    <li><code>booleano</code>: Verdadero o Falso</li>
                    <li><code>lista</code>: Colecci√≥n de elementos (ej. [1, 2, 3, 4])</li>
                </ul>

                <pre><code class="language-python">// Declaraci√≥n de variables
entero edad = 25
real temperatura = 36.5
cadena nombre = "Ana"
booleano esActivo = Verdadero
lista numeros = [1, 2, 3, 4, 5]</code></pre>

                <h3>2.2. Operadores</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Tipo</th>
                                <th>Operadores</th>
                                <th>Ejemplo</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Aritm√©ticos</td>
                                <td>+, -, *, /, MOD</td>
                                <td>resultado = a + b</td>
                            </tr>
                            <tr>
                                <td>Relacionales</td>
                                <td>=, ‚â†, &lt;, &gt;, ‚â§, ‚â•</td>
                                <td>Si edad &gt; 18 entonces...</td>
                            </tr>
                            <tr>
                                <td>L√≥gicos</td>
                                <td>Y, O, NO</td>
                                <td>Si (edad &gt; 18) Y (esEstudiante) entonces...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>2.3. Entrada y Salida</h3>
                <pre><code class="language-python">// Entrada de datos
Leer nombre
Leer edad

// Salida de datos
Escribir "Hola, ", nombre
Escribir "Tu edad es: ", edad</code></pre>
            </section>

            <!-- Estructuras de Control -->
            <section class="section">
                <h2>3. Estructuras de Control</h2>

                <h3>3.1. Condicionales</h3>
                <p>Permiten ejecutar diferentes bloques de c√≥digo seg√∫n se cumplan o no ciertas condiciones.</p>

                <pre><code class="language-python">// Estructura Si-Entonces-SiNo
Si (edad >= 18) entonces
    Escribir "Eres mayor de edad"
SiNo
    Escribir "Eres menor de edad"
FinSi

// Estructura Seg√∫n (Switch/Case)
Seg√∫n opcion hacer
    caso 1:
        Escribir "Opci√≥n 1 seleccionada"
    caso 2:
        Escribir "Opci√≥n 2 seleccionada"
    caso contrario:
        Escribir "Opci√≥n no v√°lida"
FinSegun</code></pre>

                <h3>3.2. Bucles</h3>
                <p>Permiten repetir bloques de c√≥digo m√∫ltiples veces.</p>

                <pre><code class="language-python">// Bucle Para (con contador)
Para i = 1 hasta 10 hacer
    Escribir "Iteraci√≥n: ", i
FinPara

// Bucle Mientras (condici√≥n al inicio)
Mientras (contador < 100) hacer
    contador = contador + 1
    Escribir contador
FinMientras

// Bucle Repetir-Hasta (condici√≥n al final)
Repetir
    Leer opcion
    Escribir "Opci√≥n seleccionada: ", opcion
Hasta que (opcion = "salir")</code></pre>

                <h3>3.3. Funciones y Procedimientos</h3>
                <pre><code class="language-python">// Funci√≥n (devuelve un valor)
Funcion calcularPromedio(lista numeros) : real
    real suma = 0
    Para cada num en numeros hacer
        suma = suma + num
    FinPara
    retornar suma / longitud(numeros)
FinFuncion

// Procedimiento (no devuelve valor)
Procedimiento imprimirMensaje(cadena mensaje)
    Escribir "==========================="
    Escribir mensaje
    Escribir "==========================="
FinProcedimiento</code></pre>
            </section>

            <!-- Algoritmos de IA -->
            <section class="section">
                <h2>4. Algoritmos de Inteligencia Artificial</h2>

                <h3>4.1. K-Means Clustering</h3>
                <p>K-Means es un algoritmo de <strong>aprendizaje no supervisado</strong> que agrupa datos en K clusters bas√°ndose en similitudes.</p>

                <div class="svg-container">
                    <svg width="600" height="280" viewBox="0 0 600 280" style="max-width: 100%; height: auto;">
                        <!-- Title -->
                        <text x="300" y="20" font-size="16" font-weight="bold" fill="#49B9CE" text-anchor="middle">
                            Visualizaci√≥n de K-Means (K=3)
                        </text>

                        <!-- Cluster 1 (Blue) -->
                        <circle cx="120" cy="120" r="60" fill="#49B9CE" fill-opacity="0.2" stroke="#49B9CE" stroke-width="2"/>
                        <circle cx="120" cy="120" r="8" fill="#49B9CE"/>
                        <text x="120" y="110" font-size="12" font-weight="bold" fill="#49B9CE" text-anchor="middle">C1</text>
                        <circle cx="100" cy="100" r="4" fill="#49B9CE"/>
                        <circle cx="140" cy="110" r="4" fill="#49B9CE"/>
                        <circle cx="110" cy="140" r="4" fill="#49B9CE"/>
                        <circle cx="130" cy="130" r="4" fill="#49B9CE"/>

                        <!-- Cluster 2 (Purple) -->
                        <circle cx="300" cy="120" r="60" fill="#8A7AAF" fill-opacity="0.2" stroke="#8A7AAF" stroke-width="2"/>
                        <circle cx="300" cy="120" r="8" fill="#8A7AAF"/>
                        <text x="300" y="110" font-size="12" font-weight="bold" fill="#8A7AAF" text-anchor="middle">C2</text>
                        <circle cx="280" cy="100" r="4" fill="#8A7AAF"/>
                        <circle cx="320" cy="110" r="4" fill="#8A7AAF"/>
                        <circle cx="290" cy="140" r="4" fill="#8A7AAF"/>
                        <circle cx="310" cy="130" r="4" fill="#8A7AAF"/>

                        <!-- Cluster 3 (Green) -->
                        <circle cx="480" cy="120" r="60" fill="#4CAF50" fill-opacity="0.2" stroke="#4CAF50" stroke-width="2"/>
                        <circle cx="480" cy="120" r="8" fill="#4CAF50"/>
                        <text x="480" y="110" font-size="12" font-weight="bold" fill="#4CAF50" text-anchor="middle">C3</text>
                        <circle cx="460" cy="100" r="4" fill="#4CAF50"/>
                        <circle cx="500" cy="110" r="4" fill="#4CAF50"/>
                        <circle cx="470" cy="140" r="4" fill="#4CAF50"/>
                        <circle cx="490" cy="130" r="4" fill="#4CAF50"/>

                        <!-- Legend -->
                        <circle cx="150" cy="250" r="6" fill="#49B9CE"/>
                        <text x="165" y="255" font-size="11" fill="#333">Cluster 1</text>
                        <circle cx="270" cy="250" r="6" fill="#8A7AAF"/>
                        <text x="285" y="255" font-size="11" fill="#333">Cluster 2</text>
                        <circle cx="390" cy="250" r="6" fill="#4CAF50"/>
                        <text x="405" y="255" font-size="11" fill="#333">Cluster 3</text>
                    </svg>
                </div>

                <pre><code class="language-python">Algoritmo K-Means
Entrada:
    - dataset: conjunto de puntos de datos
    - K: n√∫mero de clusters deseado
    - maxIteraciones: n√∫mero m√°ximo de iteraciones
Salida:
    - centroides: posiciones finales de los K centroides
    - asignaciones: cluster asignado a cada punto

Inicio
    // 1. Inicializaci√≥n aleatoria de centroides
    centroides = seleccionarAleatorio(dataset, K)

    // 2. Iteraci√≥n hasta convergencia
    Para iteracion = 1 hasta maxIteraciones hacer
        // Asignar cada punto al centroide m√°s cercano
        Para cada punto en dataset hacer
            distanciaMinima = Infinito
            clusterAsignado = -1

            Para cada i = 1 hasta K hacer
                distancia = calcularDistanciaEuclidiana(punto, centroides[i])
                Si distancia < distanciaMinima entonces
                    distanciaMinima = distancia
                    clusterAsignado = i
                FinSi
            FinPara

            asignaciones[punto] = clusterAsignado
        FinPara

        // Recalcular centroides
        centroidesAnteriores = centroides
        Para cada i = 1 hasta K hacer
            puntosCluster = obtenerPuntos(dataset, asignaciones, i)
            centroides[i] = calcularPromedio(puntosCluster)
        FinPara

        // Verificar convergencia
        Si centroides = centroidesAnteriores entonces
            romper // Convergencia alcanzada
        FinSi
    FinPara

    retornar centroides, asignaciones
Fin</code></pre>

                <h3>4.2. √Årbol de Decisi√≥n (ID3)</h3>
                <p>El algoritmo ID3 construye √°rboles de decisi√≥n para clasificaci√≥n usando la <strong>ganancia de informaci√≥n</strong>.</p>

                <pre><code class="language-python">Funcion construirArbolID3(datos, atributos, atributoObjetivo) : Arbol
Inicio
    // Caso base 1: Todos los ejemplos tienen la misma clase
    Si todosLosMismaClase(datos, atributoObjetivo) entonces
        retornar crearHoja(datos[0][atributoObjetivo])
    FinSi

    // Caso base 2: No quedan atributos para dividir
    Si atributos est√° vac√≠o entonces
        retornar crearHoja(claseMayoritaria(datos, atributoObjetivo))
    FinSi

    // Paso recursivo: Seleccionar el mejor atributo
    mejorAtributo = seleccionarMejorAtributo(datos, atributos)
    arbol = crearNodo(mejorAtributo)

    // Dividir datos seg√∫n valores del mejor atributo
    valores = obtenerValoresUnicos(datos, mejorAtributo)
    Para cada valor en valores hacer
        subconjunto = filtrarDatos(datos, mejorAtributo, valor)

        Si subconjunto est√° vac√≠o entonces
            rama = crearHoja(claseMayoritaria(datos, atributoObjetivo))
        SiNo
            nuevosAtributos = atributos - mejorAtributo
            rama = construirArbolID3(subconjunto, nuevosAtributos, atributoObjetivo)
        FinSi

        agregarRama(arbol, valor, rama)
    FinPara

    retornar arbol
FinFuncion

Funcion seleccionarMejorAtributo(datos, atributos) : Atributo
Inicio
    entropiaBase = calcularEntropia(datos)
    mejorGanancia = -Infinito
    mejorAtributo = null

    Para cada atributo en atributos hacer
        ganancia = entropiaBase
        valores = obtenerValoresUnicos(datos, atributo)

        Para cada valor en valores hacer
            subconjunto = filtrarDatos(datos, atributo, valor)
            probabilidad = longitud(subconjunto) / longitud(datos)
            ganancia = ganancia - (probabilidad * calcularEntropia(subconjunto))
        FinPara

        Si ganancia > mejorGanancia entonces
            mejorGanancia = ganancia
            mejorAtributo = atributo
        FinSi
    FinPara

    retornar mejorAtributo
FinFuncion</code></pre>
            </section>

            <!-- Algoritmos de Big Data -->
            <section class="section">
                <h2>5. Algoritmos de Big Data</h2>

                <h3>5.1. MapReduce</h3>
                <p>MapReduce es un paradigma de programaci√≥n para procesar grandes vol√∫menes de datos de forma distribuida.</p>

                <div class="svg-container">
                    <svg width="700" height="350" viewBox="0 0 700 350" style="max-width: 100%; height: auto;">
                        <!-- Title -->
                        <text x="350" y="25" font-size="18" font-weight="bold" fill="#49B9CE" text-anchor="middle">
                            Flujo MapReduce: Conteo de Palabras
                        </text>

                        <!-- Input Data -->
                        <rect x="50" y="50" width="150" height="80" fill="#E8F7FA" stroke="#49B9CE" stroke-width="2" rx="5"/>
                        <text x="125" y="70" font-size="12" font-weight="bold" fill="#49B9CE" text-anchor="middle">Datos de Entrada</text>
                        <text x="125" y="90" font-size="10" fill="#333" text-anchor="middle">"hola mundo"</text>
                        <text x="125" y="105" font-size="10" fill="#333" text-anchor="middle">"hola big data"</text>
                        <text x="125" y="120" font-size="10" fill="#333" text-anchor="middle">"mundo big data"</text>

                        <!-- Map Phase -->
                        <path d="M 200 90 L 250 90" stroke="#FFA726" stroke-width="2" fill="none" marker-end="url(#arrowOrange)"/>
                        <rect x="250" y="50" width="150" height="80" fill="#FFF3E0" stroke="#FFA726" stroke-width="2" rx="5"/>
                        <text x="325" y="70" font-size="12" font-weight="bold" fill="#FFA726" text-anchor="middle">Fase Map</text>
                        <text x="325" y="90" font-size="9" fill="#333" text-anchor="middle">(hola, 1), (mundo, 1)</text>
                        <text x="325" y="105" font-size="9" fill="#333" text-anchor="middle">(hola, 1), (big, 1), (data, 1)</text>
                        <text x="325" y="120" font-size="9" fill="#333" text-anchor="middle">(mundo, 1), (big, 1), (data, 1)</text>

                        <!-- Shuffle & Sort -->
                        <path d="M 400 90 L 450 90" stroke="#8A7AAF" stroke-width="2" fill="none" marker-end="url(#arrowPurple)"/>
                        <rect x="280" y="150" width="160" height="50" fill="#F3E5F5" stroke="#8A7AAF" stroke-width="2" rx="5"/>
                        <text x="360" y="170" font-size="12" font-weight="bold" fill="#8A7AAF" text-anchor="middle">Shuffle & Sort</text>
                        <text x="360" y="190" font-size="10" fill="#333" text-anchor="middle">Agrupa por clave</text>

                        <!-- Reduce Input -->
                        <path d="M 360 200 L 360 240" stroke="#8A7AAF" stroke-width="2" fill="none" marker-end="url(#arrowPurple)"/>
                        <rect x="250" y="240" width="220" height="80" fill="#F3E5F5" stroke="#8A7AAF" stroke-width="2" rx="5"/>
                        <text x="360" y="260" font-size="12" font-weight="bold" fill="#8A7AAF" text-anchor="middle">Datos Agrupados</text>
                        <text x="360" y="280" font-size="9" fill="#333" text-anchor="middle">hola ‚Üí [1, 1]</text>
                        <text x="360" y="295" font-size="9" fill="#333" text-anchor="middle">mundo ‚Üí [1, 1]</text>
                        <text x="360" y="310" font-size="9" fill="#333" text-anchor="middle">big ‚Üí [1, 1], data ‚Üí [1, 1]</text>

                        <!-- Reduce Phase -->
                        <path d="M 470 280 L 500 280" stroke="#4CAF50" stroke-width="2" fill="none" marker-end="url(#arrowGreen)"/>
                        <rect x="500" y="240" width="150" height="80" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2" rx="5"/>
                        <text x="575" y="260" font-size="12" font-weight="bold" fill="#4CAF50" text-anchor="middle">Fase Reduce</text>
                        <text x="575" y="280" font-size="10" fill="#333" text-anchor="middle">(hola, 2)</text>
                        <text x="575" y="295" font-size="10" fill="#333" text-anchor="middle">(mundo, 2)</text>
                        <text x="575" y="310" font-size="10" fill="#333" text-anchor="middle">(big, 2), (data, 2)</text>

                        <!-- Arrow markers -->
                        <defs>
                            <marker id="arrowOrange" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#FFA726"/>
                            </marker>
                            <marker id="arrowPurple" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#8A7AAF"/>
                            </marker>
                            <marker id="arrowGreen" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#4CAF50"/>
                            </marker>
                        </defs>
                    </svg>
                </div>

                <pre><code class="language-python">// Ejemplo: Conteo de palabras con MapReduce

// Funci√≥n Map: Procesa cada l√≠nea de texto
Funcion map(cadena linea) : lista de pares (clave, valor)
Inicio
    palabras = dividir(linea, " ")
    resultado = []

    Para cada palabra en palabras hacer
        agregar(resultado, (palabra, 1))
    FinPara

    retornar resultado
FinFuncion

// Funci√≥n Reduce: Suma los conteos de cada palabra
Funcion reduce(cadena palabra, lista valores) : par (clave, valor)
Inicio
    suma = 0

    Para cada valor en valores hacer
        suma = suma + valor
    FinPara

    retornar (palabra, suma)
FinFuncion

// Algoritmo principal MapReduce
Algoritmo MapReduceConteo
Entrada: archivos de texto distribuidos
Salida: conteo de palabras

Inicio
    // Fase Map (paralela)
    resultadosMap = []
    Para cada linea en archivos hacer
        pares = map(linea)
        agregarTodos(resultadosMap, pares)
    FinPara

    // Fase Shuffle & Sort
    datosAgrupados = agruparPorClave(resultadosMap)

    // Fase Reduce (paralela)
    resultadoFinal = []
    Para cada (palabra, listaValores) en datosAgrupados hacer
        resultado = reduce(palabra, listaValores)
        agregar(resultadoFinal, resultado)
    FinPara

    retornar resultadoFinal
Fin</code></pre>

                <h3>5.2. Stream Processing</h3>
                <p>Procesamiento de datos en tiempo real, t√≠pico en an√°lisis de redes sociales o sensores IoT.</p>

                <pre><code class="language-python">// Ejemplo: Detectar trending topics en Twitter

Algoritmo StreamProcessingTrends
Entrada: stream de tweets en tiempo real
Salida: hashtags en tendencia

Inicio
    ventanaTiempo = 5 minutos
    hashtagConteo = diccionario()
    umbralTrending = 100

    // Procesamiento continuo del stream
    Mientras haya datos en el stream hacer
        tweet = leerSiguienteTweet(stream)
        tiempoActual = obtenerTiempoActual()

        // Extraer hashtags del tweet
        hashtags = extraerHashtags(tweet.texto)

        Para cada hashtag en hashtags hacer
            // Actualizar contador
            Si hashtag existe en hashtagConteo entonces
                hashtagConteo[hashtag].contador++
                agregar(hashtagConteo[hashtag].timestamps, tiempoActual)
            SiNo
                hashtagConteo[hashtag] = {
                    contador: 1,
                    timestamps: [tiempoActual]
                }
            FinSi
        FinPara

        // Limpiar datos antiguos (fuera de ventana de tiempo)
        Para cada hashtag en hashtagConteo hacer
            tiemposValidos = []
            Para cada timestamp en hashtagConteo[hashtag].timestamps hacer
                Si (tiempoActual - timestamp) <= ventanaTiempo entonces
                    agregar(tiemposValidos, timestamp)
                FinSi
            FinPara
            hashtagConteo[hashtag].timestamps = tiemposValidos
            hashtagConteo[hashtag].contador = longitud(tiemposValidos)
        FinPara

        // Identificar trending topics
        trending = []
        Para cada hashtag en hashtagConteo hacer
            Si hashtagConteo[hashtag].contador >= umbralTrending entonces
                agregar(trending, hashtag)
            FinSi
        FinPara

        // Publicar resultados
        Si trending no est√° vac√≠o entonces
            Escribir "Trending ahora: ", trending
        FinSi
    FinMientras
Fin</code></pre>
            </section>

            <!-- Mejores Pr√°cticas -->
            <section class="section">
                <h2>6. Mejores Pr√°cticas</h2>

                <div class="feature-cards">
                    <div class="feature-card">
                        <h4>üìù Claridad y Legibilidad</h4>
                        <p>Usa nombres descriptivos para variables y funciones. Evita abreviaturas confusas.</p>
                        <pre><code class="language-python">// Mal
real c = (t * 1.8) + 32

// Bien
real fahrenheit = (celsius * 1.8) + 32</code></pre>
                    </div>

                    <div class="feature-card">
                        <h4>üé® Indentaci√≥n Consistente</h4>
                        <p>Mant√©n una indentaci√≥n uniforme para visualizar claramente la estructura del c√≥digo.</p>
                        <pre><code class="language-python">Si condicion entonces
    instruccion1
    Si otraCondicion entonces
        instruccion2
    FinSi
FinSi</code></pre>
                    </div>

                    <div class="feature-card">
                        <h4>üí¨ Comentarios √ötiles</h4>
                        <p>Incluye comentarios que expliquen el "por qu√©", no solo el "qu√©".</p>
                        <pre><code class="language-python">// Usar K=5 basado en la regla del codo
// para optimizar varianza intra-cluster
K = 5</code></pre>
                    </div>

                    <div class="feature-card">
                        <h4>üîÑ Modularizaci√≥n</h4>
                        <p>Divide algoritmos complejos en funciones peque√±as y reutilizables.</p>
                        <pre><code class="language-python">// En lugar de un algoritmo monol√≠tico
resultado = procesarDatos(datos)

// Usa funciones espec√≠ficas
datosFiltrados = filtrar(datos)
datosNormalizados = normalizar(datosFiltrados)
resultado = analizar(datosNormalizados)</code></pre>
                    </div>

                    <div class="feature-card">
                        <h4>‚ö†Ô∏è Manejo de Errores</h4>
                        <p>Anticipa casos especiales y situaciones de error.</p>
                        <pre><code class="language-python">Si lista est√° vac√≠a entonces
    Escribir "Error: No hay datos"
    retornar
FinSi</code></pre>
                    </div>

                    <div class="feature-card">
                        <h4>üß™ Casos de Prueba</h4>
                        <p>Documenta casos de prueba para validar el algoritmo.</p>
                        <pre><code class="language-python">// Caso de prueba:
// Entrada: [5, 2, 8, 1, 9]
// Salida esperada: [1, 2, 5, 8, 9]</code></pre>
                    </div>
                </div>
            </section>

            <!-- Caso de Estudio -->
            <section class="section">
                <h2>7. Caso de Estudio: Sistema de Recomendaci√≥n de Netflix</h2>

                <div class="highlight-box">
                    <h4>Contexto del Proyecto</h4>
                    <p>Dise√±aremos un algoritmo simplificado de recomendaci√≥n de pel√≠culas basado en <strong>filtrado colaborativo</strong>, similar al usado por Netflix para sugerir contenido a sus usuarios.</p>
                </div>

                <h3>Objetivo</h3>
                <p>Recomendar pel√≠culas a un usuario bas√°ndose en las calificaciones de usuarios con gustos similares.</p>

                <h3>Pseudoc√≥digo del Sistema</h3>

                <pre><code class="language-python">// Estructura de datos
Estructura Usuario {
    entero id
    cadena nombre
    diccionario calificaciones  // {peliculaId: puntuacion}
}

Estructura Pelicula {
    entero id
    cadena titulo
    lista generos
}

// Funci√≥n principal de recomendaci√≥n
Funcion recomendarPeliculas(Usuario usuarioActivo, lista todosUsuarios,
                             lista todasPeliculas, entero numRecomendaciones) : lista
Inicio
    // Paso 1: Encontrar usuarios similares
    usuariosSimilares = []

    Para cada usuario en todosUsuarios hacer
        Si usuario.id ‚â† usuarioActivo.id entonces
            similitud = calcularSimilitud(usuarioActivo, usuario)
            Si similitud > 0.5 entonces  // Umbral de similitud
                agregar(usuariosSimilares, {usuario: usuario, similitud: similitud})
            FinSi
        FinSi
    FinPara

    // Ordenar por similitud descendente
    ordenar(usuariosSimilares, por: similitud, orden: descendente)

    // Paso 2: Recopilar pel√≠culas candidatas
    peliculasCandidatas = diccionario()  // {peliculaId: [calificaciones ponderadas]}

    Para cada usuarioSimilar en usuariosSimilares hacer
        Para cada (peliculaId, calificacion) en usuarioSimilar.usuario.calificaciones hacer
            // Solo considerar pel√≠culas que el usuario activo no ha visto
            Si no existe peliculaId en usuarioActivo.calificaciones entonces
                // Ponderar calificaci√≥n por similitud del usuario
                calificacionPonderada = calificacion * usuarioSimilar.similitud

                Si existe peliculaId en peliculasCandidatas entonces
                    agregar(peliculasCandidatas[peliculaId], calificacionPonderada)
                SiNo
                    peliculasCandidatas[peliculaId] = [calificacionPonderada]
                FinSi
            FinSi
        FinPara
    FinPara

    // Paso 3: Calcular puntuaci√≥n promedio para cada pel√≠cula
    recomendaciones = []

    Para cada (peliculaId, calificaciones) en peliculasCandidatas hacer
        puntuacionPromedio = calcularPromedio(calificaciones)
        pelicula = obtenerPeliculaPorId(todasPeliculas, peliculaId)
        agregar(recomendaciones, {
            pelicula: pelicula,
            puntuacion: puntuacionPromedio
        })
    FinPara

    // Paso 4: Ordenar y retornar top N recomendaciones
    ordenar(recomendaciones, por: puntuacion, orden: descendente)
    retornar primeros(recomendaciones, numRecomendaciones)
FinFuncion

// Calcular similitud entre usuarios usando correlaci√≥n de Pearson
Funcion calcularSimilitud(Usuario user1, Usuario user2) : real
Inicio
    // Encontrar pel√≠culas calificadas por ambos usuarios
    peliculasComunes = interseccion(user1.calificaciones.claves(),
                                     user2.calificaciones.claves())

    Si longitud(peliculasComunes) = 0 entonces
        retornar 0  // Sin pel√≠culas en com√∫n
    FinSi

    // Calcular promedios
    suma1 = 0
    suma2 = 0
    Para cada peliculaId en peliculasComunes hacer
        suma1 = suma1 + user1.calificaciones[peliculaId]
        suma2 = suma2 + user2.calificaciones[peliculaId]
    FinPara
    promedio1 = suma1 / longitud(peliculasComunes)
    promedio2 = suma2 / longitud(peliculasComunes)

    // Calcular correlaci√≥n de Pearson
    numerador = 0
    sumaCuadrados1 = 0
    sumaCuadrados2 = 0

    Para cada peliculaId en peliculasComunes hacer
        diferencia1 = user1.calificaciones[peliculaId] - promedio1
        diferencia2 = user2.calificaciones[peliculaId] - promedio2

        numerador = numerador + (diferencia1 * diferencia2)
        sumaCuadrados1 = sumaCuadrados1 + (diferencia1 * diferencia1)
        sumaCuadrados2 = sumaCuadrados2 + (diferencia2 * diferencia2)
    FinPara

    denominador = raizCuadrada(sumaCuadrados1 * sumaCuadrados2)

    Si denominador = 0 entonces
        retornar 0
    SiNo
        retornar numerador / denominador
    FinSi
FinFuncion

// Algoritmo principal
Inicio
    // Inicializar datos
    todosUsuarios = cargarUsuarios()
    todasPeliculas = cargarPeliculas()
    usuarioActivo = obtenerUsuarioActual()

    // Generar recomendaciones
    recomendaciones = recomendarPeliculas(usuarioActivo, todosUsuarios,
                                          todasPeliculas, 10)

    // Mostrar resultados
    Escribir "Pel√≠culas recomendadas para ", usuarioActivo.nombre, ":"
    Escribir "=================================================="

    Para cada i = 1 hasta longitud(recomendaciones) hacer
        Escribir i, ". ", recomendaciones[i].pelicula.titulo
        Escribir "   Puntuaci√≥n: ", recomendaciones[i].puntuacion
        Escribir "   G√©neros: ", unir(recomendaciones[i].pelicula.generos, ", ")
        Escribir "--------------------------------------------------"
    FinPara
Fin</code></pre>

                <h3>Complejidad del Algoritmo</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Operaci√≥n</th>
                                <th>Complejidad</th>
                                <th>Explicaci√≥n</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Calcular similitudes</td>
                                <td>O(U √ó P)</td>
                                <td>U usuarios, P pel√≠culas en com√∫n</td>
                            </tr>
                            <tr>
                                <td>Recopilar candidatas</td>
                                <td>O(U √ó M)</td>
                                <td>U usuarios similares, M pel√≠culas por usuario</td>
                            </tr>
                            <tr>
                                <td>Ordenar recomendaciones</td>
                                <td>O(C log C)</td>
                                <td>C pel√≠culas candidatas</td>
                            </tr>
                            <tr>
                                <td><strong>Total</strong></td>
                                <td><strong>O(U √ó P + U √ó M + C log C)</strong></td>
                                <td>Dominado por c√°lculo de similitudes</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Optimizaciones Posibles</h3>
                <ul>
                    <li><strong>Pre-c√°lculo de similitudes:</strong> Calcular y almacenar similitudes peri√≥dicamente en lugar de en tiempo real</li>
                    <li><strong>Filtrado temprano:</strong> Limitar usuarios similares a los top 50 m√°s similares</li>
                    <li><strong>Cacheo:</strong> Guardar recomendaciones generadas por un tiempo determinado</li>
                    <li><strong>Paralelizaci√≥n:</strong> Calcular similitudes en paralelo usando MapReduce</li>
                </ul>
            </section>

            <!-- Conclusiones -->
            <section class="section">
                <h2>8. Conclusiones</h2>

                <p>El pseudoc√≥digo es una herramienta esencial en el desarrollo de soluciones de IA y Big Data porque:</p>

                <ul>
                    <li>Permite dise√±ar algoritmos complejos sin preocuparse por la sintaxis de programaci√≥n espec√≠fica</li>
                    <li>Facilita la comunicaci√≥n entre equipos multidisciplinares (cient√≠ficos de datos, ingenieros, analistas)</li>
                    <li>Ayuda a identificar problemas l√≥gicos tempranamente, ahorrando tiempo de desarrollo</li>
                    <li>Sirve como documentaci√≥n clara de la l√≥gica del sistema</li>
                    <li>Es independiente de la tecnolog√≠a, permitiendo adaptaciones a diferentes plataformas</li>
                </ul>

                <div class="highlight-box">
                    <h4>Recuerda</h4>
                    <p>Un buen pseudoc√≥digo debe ser lo suficientemente detallado para que un programador pueda implementarlo, pero lo suficientemente abstracto para que no se atasque en detalles t√©cnicos espec√≠ficos de un lenguaje.</p>
                </div>

                <h3>Transici√≥n a C√≥digo Real</h3>
                <p>Una vez validado el pseudoc√≥digo, la transici√≥n a un lenguaje real (Python, Java, Scala, etc.) debe ser directa. El pseudoc√≥digo bien dise√±ado facilita enormemente esta conversi√≥n y reduce errores en la implementaci√≥n final.</p>
            </section>

            <!-- Mapa Mental -->
            <section class="section">
                <h2>9. Mapa Conceptual</h2>
                <div class="mermaid">
                    mindmap
                    root((Pseudoc√≥digo))
                    Conceptos B√°sicos
                    Variables y Tipos
                    Entero, Real, Cadena
                    Booleano, Lista
                    Operadores
                    Aritm√©ticos
                    Relacionales
                    L√≥gicos
                    Entrada/Salida
                    Leer
                    Escribir
                    Estructuras de Control
                    Condicionales
                    Si-Entonces-SiNo
                    Seg√∫n/Caso
                    Bucles
                    Para
                    Mientras
                    Repetir-Hasta
                    Funciones
                    Con retorno
                    Sin retorno
                    Algoritmos IA
                    Aprendizaje No Supervisado
                    K-Means
                    DBSCAN
                    Aprendizaje Supervisado
                    √Årboles de Decisi√≥n
                    Regresi√≥n Lineal
                    Deep Learning
                    Redes Neuronales
                    Backpropagation
                    Algoritmos Big Data
                    Procesamiento Batch
                    MapReduce
                    Spark RDD
                    Stream Processing
                    Ventanas de Tiempo
                    Agregaciones en Tiempo Real
                    Almacenamiento
                    HDFS
                    NoSQL
                    Mejores Pr√°cticas
                    Claridad
                    Nombres descriptivos
                    Comentarios √∫tiles
                    Estructura
                    Indentaci√≥n
                    Modularizaci√≥n
                    Validaci√≥n
                    Casos de prueba
                    Manejo de errores
                </div>
            </section>
        </main>
    </div>

    <!-- Footer -->
    <footer>
        <h3>iLERNA</h3>
        <p class="footer-course">Curso de Especializaci√≥n en Inteligencia Artificial y Big Data</p>
        <a href="https://www.ilerna.es/" target="_blank">www.ilerna.es</a>
        <p class="footer-info">Centro oficial de FP online y presencial. Ciclos formativos de Grado Medio y Grado
            Superior.</p>
        <div class="penguin">
            <span>üêß</span>
        </div>
    </footer>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Scripts de la lecci√≥n -->
    <script src="../js/lecciones.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>

</html>