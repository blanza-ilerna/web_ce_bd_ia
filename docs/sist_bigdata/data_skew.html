<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Data Skew en Big Data: Definici√≥n, causas (Hot Keys), consecuencias y estrategias de mitigaci√≥n (Salting, Broadcast Joins).">
    <title>Data Skew: El Problema del Sesgo de Datos | iLERNA</title>
    <link rel="stylesheet" href="../css/lecciones.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <div class="header-container">
                <div class="logo-container">
                    <a href="../index.html">
                        <img src="../img/logo-ilerna.svg" alt="Logo iLERNA">
                    </a>
                    <div class="logo-text">
                        iLERNA
                        <span>Curso de Especializaci√≥n en IA y Big Data</span>
                    </div>
                </div>
                <div class="breadcrumb">
                    <a href="../index.html">Inicio</a> ‚Ä∫
                    <a href="index.html">Sistemas de Big Data</a> ‚Ä∫
                    <span>Data Skew</span>
                </div>
            </div>
            <h1 class="text-center">Data Skew: El Enemigo de la Paralelizaci√≥n</h1>
        </header>

        <main>

            <!-- Hero Section -->
            <section class="hero-section">
                <div class="hero-content">
                    <h2>‚öñÔ∏è ¬øPor qu√© mi Cl√∫ster es Lento si tengo 100 Nodos?</h2>
                    <p class="hero-description">
                        En teor√≠a, distribuir datos entre 100 nodos deber√≠a hacer el procesamiento 100 veces m√°s r√°pido.
                        En la pr√°ctica, el <strong>Data Skew</strong> (sesgo de datos) rompe esta promesa. Ocurre cuando
                        la distribuci√≥n de los datos no es uniforme, provocando que unos pocos nodos se sobrecarguen
                        mientras el resto espera ocioso. Es la causa #1 de fallos de memoria (OOM) y rendimiento
                        pobre en Spark, Hive y Hadoop.
                    </p>
                </div>
            </section>

            <!-- Table of Contents -->
            <nav class="toc-container">
                <h3>üìë Contenido de la Lecci√≥n</h3>
                <ul class="toc-list">
                    <li><a href="#introduccion">1. ¬øQu√© es el Data Skew?</a></li>
                    <li><a href="#causas">2. Causas Comunes: El Problema de las "Hot Keys"</a></li>
                    <li><a href="#consecuencias">3. Consecuencias: El Efecto "Straggler"</a></li>
                    <li><a href="#mitigacion">4. Estrategias de Mitigaci√≥n</a></li>
                </ul>
            </nav>

            <!-- Secci√≥n 1: Introducci√≥n -->
            <section id="introduccion" class="content-section">
                <h2>1. ¬øQu√© es el Data Skew?</h2>

                <div class="highlight-box warning">
                    <h4>‚ö†Ô∏è Definici√≥n</h4>
                    <p>
                        El <strong>Data Skew</strong> es un desequilibrio en la distribuci√≥n de los datos a trav√©s de
                        las particiones o nodos de un sistema distribuido. En lugar de tener una carga de trabajo
                        repartida equitativamente, algunos nodos reciben una cantidad desproporcionada de datos.
                    </p>
                </div>

                <h3>Visualizando el Problema</h3>
                <p>
                    Imaginemos que tenemos que procesar 1 mill√≥n de registros usando 4 nodos.
                </p>

                <div class="grid-features" style="grid-template-columns: 1fr 1fr;">
                    <div class="feature-card">
                        <h4>‚úÖ Distribuci√≥n Uniforme (Ideal)</h4>
                        <div
                            style="display: flex; align-items: flex-end; justify-content: space-around; height: 150px; border-bottom: 2px solid #333; padding-bottom: 10px;">
                            <div
                                style="width: 20%; background-color: #43A047; height: 80%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                25%</div>
                            <div
                                style="width: 20%; background-color: #43A047; height: 80%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                25%</div>
                            <div
                                style="width: 20%; background-color: #43A047; height: 80%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                25%</div>
                            <div
                                style="width: 20%; background-color: #43A047; height: 80%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                25%</div>
                        </div>
                        <p style="text-align: center; margin-top: 10px;">Todos los nodos terminan al mismo tiempo.</p>
                    </div>

                    <div class="feature-card">
                        <h4>‚ùå Con Data Skew (Realidad)</h4>
                        <div
                            style="display: flex; align-items: flex-end; justify-content: space-around; height: 150px; border-bottom: 2px solid #333; padding-bottom: 10px;">
                            <div
                                style="width: 20%; background-color: #C73E1D; height: 95%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                80%</div>
                            <div
                                style="width: 20%; background-color: #F18F01; height: 10%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                5%</div>
                            <div
                                style="width: 20%; background-color: #F18F01; height: 5%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                5%</div>
                            <div
                                style="width: 20%; background-color: #F18F01; height: 10%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                10%</div>
                        </div>
                        <p style="text-align: center; margin-top: 10px;">Un nodo trabaja mientras el resto espera.</p>
                    </div>
                </div>

            </section>

            <!-- Secci√≥n 2: Causas -->
            <section id="causas" class="content-section">
                <h2>2. Causas Comunes: El Problema de las "Hot Keys"</h2>

                <p>
                    La causa m√°s frecuente de Data Skew es la existencia de <strong>Hot Keys</strong>: claves de
                    particionado que aparecen con mucha m√°s frecuencia que otras.
                </p>

                <div class="grid-features">
                    <div class="feature-card">
                        <h4>üåç Particionado por Pa√≠s</h4>
                        <p><strong>Escenario:</strong> Procesar logs de acceso global.</p>
                        <p><strong>Problema:</strong> Si particionamos por `country_code`, el nodo que procese "US"
                            (Estados Unidos) o "CN" (China) tendr√° cientos de millones de registros, mientras que el
                            nodo que procese "AD" (Andorra) tendr√° muy pocos.</p>
                    </div>

                    <div class="feature-card">
                        <h4>üì± Redes Sociales (Claves NULL)</h4>
                        <p><strong>Escenario:</strong> Unir tablas de usuarios.</p>
                        <p><strong>Problema:</strong> Los valores `NULL` o vac√≠os a menudo se env√≠an al mismo
                            particionador. Si el 30% de tus registros tienen `user_id = NULL`, todos ir√°n al mismo nodo,
                            colaps√°ndolo inmediatamente.</p>
                    </div>

                    <div class="feature-card">
                        <h4>‚≠ê Influencers y Bestsellers</h4>
                        <p><strong>Escenario:</strong> E-commerce o Twitter.</p>
                        <p><strong>Problema:</strong> Un producto viral en Amazon o un tweet de una celebridad genera
                            millones de interacciones. Al hacer un `GROUP BY product_id` o `JOIN` por usuario, esa clave
                            espec√≠fica sobrecarga su nodo.</p>
                    </div>
                </div>

            </section>

            <!-- Secci√≥n 3: Consecuencias -->
            <section id="consecuencias" class="content-section">
                <h2>3. Consecuencias: El Efecto "Straggler"</h2>

                <div class="highlight-box info">
                    <h4>üê¢ El Problema del Nodo M√°s Lento</h4>
                    <p>
                        En computaci√≥n distribuida, <strong>la velocidad del cl√∫ster es la velocidad de su nodo m√°s
                            lento</strong>.
                        Si 99 nodos terminan en 1 minuto pero 1 nodo tarda 1 hora debido al skew, el trabajo total tarda
                        1 hora.
                    </p>
                </div>

                <div class="grid-features">
                    <div class="feature-card" style="border-left: 4px solid #C73E1D;">
                        <h4>1. Desperdicio de Recursos</h4>
                        <p>El 99% de tu cl√∫ster (CPU y RAM) se queda ocioso esperando a que termine el nodo
                            sobrecargado. Est√°s pagando por 100 servidores pero usando efectivamente solo 1 al final.
                        </p>
                    </div>

                    <div class="feature-card" style="border-left: 4px solid #C73E1D;">
                        <h4>2. Errores Out Of Memory (OOM)</h4>
                        <p>Si la cantidad de datos para una sola clave excede la memoria RAM de un solo nodo, el proceso
                            fallar√° con un error de memoria, sin importar cu√°n grande sea el cl√∫ster total.</p>
                    </div>

                    <div class="feature-card" style="border-left: 4px solid #C73E1D;">
                        <h4>3. Latencia Impredecible</h4>
                        <p>Trabajos que normalmente toman minutos pueden saltar a horas aleatoriamente dependiendo de la
                            distribuci√≥n de datos del d√≠a (ej. Black Friday).</p>
                    </div>
                </div>
            </section>

            <!-- Secci√≥n 4: Mitigaci√≥n -->
            <section id="mitigacion" class="content-section">
                <h2>4. Estrategias de Mitigaci√≥n</h2>

                <h3>1. Salting (Salado de Claves)</h3>
                <p>
                    Consiste en a√±adir un sufijo aleatorio a las claves que sufren de skew para distribuirlas en
                    m√∫ltiples particiones.
                </p>
                <div class="highlight-box success">
                    <h4>üõ†Ô∏è C√≥mo funciona el Salting</h4>
                    <ol>
                        <li>Identificar la clave problem√°tica (ej. "US").</li>
                        <li>A√±adir un sufijo aleatorio del 1 al N (ej. "US_1", "US_2", ..., "US_5").</li>
                        <li>Ahora los datos de "US" se reparten entre 5 nodos en lugar de 1.</li>
                        <li>Realizar la agregaci√≥n parcial en cada nodo.</li>
                        <li>Eliminar el sufijo y realizar la agregaci√≥n final global.</li>
                    </ol>
                </div>

                <h3>2. Broadcast Join (Map-Side Join)</h3>
                <p>
                    Si una de las tablas es peque√±a, en lugar de barajar (shuffle) ambas tablas, enviamos una copia
                    completa de la tabla peque√±a a todos los nodos.
                </p>
                <ul>
                    <li><strong>Ventaja:</strong> Evita el shuffle de la tabla grande, eliminando el skew de red.</li>
                    <li><strong>Requisito:</strong> Una tabla debe caber en la memoria de cada nodo.</li>
                </ul>

                <h3>3. Filtrado de Skew (Arquitectura Lambda)</h3>
                <pre><code class="language-python"># Pseudoc√≥digo de estrategia de aislamiento
# 1. Separar los datos en dos streams
df_normal = df.filter(col("country") != "US")
df_skewed = df.filter(col("country") == "US")

# 2. Procesar df_normal de forma est√°ndar (r√°pido)
res_normal = df_normal.groupBy("country").count()

# 3. Procesar df_skewed con t√©cnicas especiales (ej. m√°s paralelismo o salting)
res_skewed = df_skewed.repartition(100).groupBy("country").count()

# 4. Unir resultados
final_result = res_normal.union(res_skewed)</code></pre>

            </section>

        </main>

        <footer>
            <h3>iLERNA</h3>
            <p class="footer-course">Curso de Especializaci√≥n en Inteligencia Artificial y Big Data</p>
            <a href="https://www.ilerna.es/" target="_blank">www.ilerna.es</a>
            <div class="penguin">
                <span>üêß</span>
            </div>
        </footer>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../js/lecciones.js"></script>
</body>

</html>