<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Espacio de Estados y Estrategias de B√∫squeda - Sistemas de ML">
    <meta name="keywords" content="Espacio de Estados, B√∫squeda, Algoritmos, A*, BFS, DFS">
    <meta name="author" content="Bjlanza">
    <title>Espacio de Estados y Estrategias de B√∫squeda | Sistemas de ML</title>
    <link rel="stylesheet" href="../css/lecciones.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo-container">
                <a href="../index.html">
                    <img src="../img/logo-ilerna.svg" alt="Logo iLERNA">
                </a>
                <div class="logo-text">
                    Curso de Especializaci√≥n
                    <span>Inteligencia Artificial y Big Data</span>
                </div>
            </div>
            <nav class="breadcrumb">
                <a href="../index.html">Inicio</a> ‚Üí
                <a href="index.html">Sistemas de ML</a> ‚Üí
                <span>Espacio de Estados y B√∫squeda</span>
            </nav>
        </div>
    </header>

    <main>
        <h1 class="text-center">Espacio de Estados y Estrategias de B√∫squeda</h1>
        <p class="subtitle text-center">Fundamentos de la Resoluci√≥n de Problemas en Inteligencia Artificial</p>

        <!-- SECCI√ìN 1: INTRODUCCI√ìN -->
        <section class="section">
            <h2>Introducci√≥n: Resolviendo Problemas con IA</h2>
            <p>
                La <strong>resoluci√≥n de problemas mediante b√∫squeda</strong> es uno de los pilares fundamentales de la Inteligencia Artificial. Desde encontrar la ruta m√°s corta en un GPS hasta resolver un cubo de Rubik o jugar al ajedrez, todos estos desaf√≠os comparten una caracter√≠stica com√∫n: pueden modelarse como la <strong>exploraci√≥n de un espacio de estados</strong> en busca de una soluci√≥n √≥ptima.
            </p>
            <p>
                Un <strong>espacio de estados</strong> representa todas las configuraciones posibles de un problema, mientras que las <strong>estrategias de b√∫squeda</strong> son los algoritmos que exploran este espacio de manera eficiente para encontrar la soluci√≥n. La diferencia entre una b√∫squeda eficiente y una ineficiente puede significar la diferencia entre segundos y a√±os de c√≥mputo.
            </p>

            <div class="highlight-box">
                <p class="tech-title">üó∫Ô∏è Ejemplo Real: Google Maps</p>
                <p>Cuando calculas una ruta en Google Maps, el sistema explora millones de estados posibles (intersecciones, calles) usando el algoritmo <strong>A*</strong>, que combina la distancia recorrida con una estimaci√≥n heur√≠stica de la distancia restante. Esto permite encontrar la ruta √≥ptima en milisegundos, evaluando solo una fracci√≥n del espacio total de estados.</p>
            </div>

            <h3 class="color-primary mt-2">Conceptos Fundamentales</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>Estado</h4>
                    <p>Configuraci√≥n espec√≠fica del problema en un momento dado. Ejemplo: posici√≥n actual en un mapa.</p>
                </div>
                <div class="feature-card secondary">
                    <h4>Acci√≥n</h4>
                    <p>Operaci√≥n que transforma un estado en otro. Ejemplo: moverse de una intersecci√≥n a otra.</p>
                </div>
                <div class="feature-card">
                    <h4>Estado Inicial</h4>
                    <p>Punto de partida del problema. Ejemplo: tu ubicaci√≥n actual al abrir el GPS.</p>
                </div>
                <div class="feature-card secondary">
                    <h4>Estado Meta</h4>
                    <p>Configuraci√≥n que satisface el objetivo. Ejemplo: destino final en tu ruta.</p>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN 2: ESPACIO DE ESTADOS -->
        <section class="section">
            <h2>El Espacio de Estados</h2>

            <h3 class="color-primary">üåê Definici√≥n y Representaci√≥n</h3>
            <p>
                El <strong>espacio de estados</strong> es el conjunto de todas las configuraciones posibles del problema, junto con las transiciones que las conectan. Se puede visualizar como un <strong>grafo</strong> en el que:
            </p>

            <ul style="margin-left: 1.5rem; line-height: 1.75; margin-bottom: 1.5rem;">
                <li><strong>Los nodos</strong> representan estados (configuraciones del problema)</li>
                <li><strong>Las aristas</strong> representan acciones (transiciones entre estados)</li>
                <li><strong>Los pesos</strong> en las aristas representan el coste de cada acci√≥n</li>
            </ul>

            <!-- VISUALIZACI√ìN SVG DEL GRAFO -->
            <svg width="800" height="500" style="border: 2px solid var(--border-color); border-radius: 1rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); background-color: #fafafa; display: block; margin: 0 auto 1.5rem auto; max-width: 100%;">
                <text x="400" y="30" font-size="18" font-weight="bold" fill="var(--color-primary)" text-anchor="middle" font-family="Montserrat">Espacio de Estados como Grafo</text>
                <text x="400" y="50" font-size="13" fill="#555555" text-anchor="middle" font-family="Montserrat">Ejemplo: Navegaci√≥n entre ciudades</text>

                <circle cx="100" cy="150" r="40" fill="#A8E6A1" stroke="#4CAF50" stroke-width="3"/>
                <text x="100" y="145" font-size="12" font-weight="bold" fill="#333333" text-anchor="middle" font-family="Montserrat">Madrid</text>
                <text x="100" y="160" font-size="10" fill="#555555" text-anchor="middle" font-family="Montserrat">(Inicio)</text>

                <circle cx="300" cy="100" r="35" fill="#E8F7FA" stroke="var(--color-primary)" stroke-width="2"/>
                <text x="300" y="105" font-size="11" font-weight="bold" fill="#333333" text-anchor="middle" font-family="Montserrat">Zaragoza</text>

                <circle cx="500" cy="150" r="35" fill="#E8F7FA" stroke="var(--color-primary)" stroke-width="2"/>
                <text x="500" y="155" font-size="11" font-weight="bold" fill="#333333" text-anchor="middle" font-family="Montserrat">Valencia</text>

                <circle cx="300" cy="280" r="35" fill="#E8F7FA" stroke="var(--color-primary)" stroke-width="2"/>
                <text x="300" y="285" font-size="11" font-weight="bold" fill="#333333" text-anchor="middle" font-family="Montserrat">Toledo</text>

                <circle cx="700" cy="150" r="40" fill="#FFE5B4" stroke="#FFA726" stroke-width="3"/>
                <text x="700" y="145" font-size="12" font-weight="bold" fill="#333333" text-anchor="middle" font-family="Montserrat">Barcelona</text>
                <text x="700" y="160" font-size="10" fill="#555555" text-anchor="middle" font-family="Montserrat">(Meta)</text>

                <defs>
                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <path d="M0,0 L0,6 L9,3 z" fill="#555555"/>
                    </marker>
                </defs>

                <line x1="135" y1="135" x2="265" y2="110" stroke="#555555" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="200" y="115" font-size="11" fill="var(--color-primary)" font-weight="bold" font-family="Montserrat">315km</text>

                <line x1="335" y1="105" x2="465" y2="145" stroke="#555555" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="400" y="120" font-size="11" fill="var(--color-primary)" font-weight="bold" font-family="Montserrat">355km</text>

                <line x1="535" y1="155" x2="660" y2="155" stroke="#555555" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="597" y="145" font-size="11" fill="var(--color-primary)" font-weight="bold" font-family="Montserrat">349km</text>

                <line x1="125" y1="180" x2="270" y2="265" stroke="#555555" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="200" y="235" font-size="11" fill="var(--color-primary)" font-weight="bold" font-family="Montserrat">72km</text>

                <line x1="300" y1="315" x2="490" y2="180" stroke="#555555" stroke-width="2" marker-end="url(#arrow)"/>
                <text x="380" y="260" font-size="11" fill="var(--color-primary)" font-weight="bold" font-family="Montserrat">290km</text>

                <rect x="50" y="380" width="700" height="90" fill="white" stroke="var(--border-color)" stroke-width="2" rx="8"/>
                <text x="400" y="405" font-size="14" font-weight="bold" fill="var(--color-secondary)" text-anchor="middle" font-family="Montserrat">Componentes del Problema</text>
                <text x="400" y="430" font-size="12" fill="#333333" text-anchor="middle" font-family="Montserrat">‚Ä¢ Estado Inicial: Madrid | ‚Ä¢ Estado Meta: Barcelona</text>
                <text x="400" y="450" font-size="12" fill="#333333" text-anchor="middle" font-family="Montserrat">‚Ä¢ Acciones: Viajar entre ciudades conectadas</text>
                <text x="400" y="465" font-size="12" fill="#333333" text-anchor="middle" font-family="Montserrat">‚Ä¢ Coste: Distancia en kil√≥metros</text>
            </svg>

            <h3 class="color-secondary mt-2">Caracter√≠sticas del Espacio de Estados</h3>
            <div class="comparison-grid">
                <div class="highlight-box">
                    <h4 class="color-primary">üìê Tama√±o del Espacio</h4>
                    <p>N√∫mero total de estados posibles. Puede ser finito (8-puzzle con 9!/2 = 181,440 estados) o infinito (ajedrez con ~10‚Å¥¬≥ posiciones legales).</p>
                </div>

                <div class="highlight-box secondary">
                    <h4 class="color-secondary">üå≥ Factor de Ramificaci√≥n</h4>
                    <p>N√∫mero promedio de acciones disponibles desde cada estado. El ajedrez tiene factor ~35, mientras que el parch√≠s tiene ~10.</p>
                </div>

                <div class="highlight-box">
                    <h4 class="color-primary">üìè Profundidad de la Soluci√≥n</h4>
                    <p>N√∫mero m√≠nimo de pasos desde el estado inicial a la meta. Afecta directamente la complejidad del problema.</p>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN 3: ESTRATEGIAS DE B√öSQUEDA NO INFORMADA -->
        <section class="section">
            <h2>Estrategias de B√∫squeda No Informada</h2>
            <p>
                Las <strong>b√∫squedas no informadas</strong> (o ciegas) exploran el espacio sin usar conocimiento espec√≠fico del dominio. Solo distinguen estados meta de no-meta.
            </p>

            <h3 class="color-primary mt-2">1. B√∫squeda en Anchura (BFS - Breadth-First Search)</h3>
            <div class="highlight-box">
                <p><strong>Estrategia:</strong> Explora todos los nodos a profundidad <em>d</em> antes de explorar nodos a profundidad <em>d+1</em>.</p>
                <p><strong>Implementaci√≥n:</strong> Usa una cola FIFO (First In, First Out)</p>

                <div class="highlight-box secondary" style="margin-top: 1rem;">
                    <p class="tech-title">Caracter√≠sticas:</p>
                    <ul style="margin-left: 1.5rem; line-height: 1.6;">
                        <li>‚úÖ <strong>Completo:</strong> Encuentra soluci√≥n si existe</li>
                        <li>‚úÖ <strong>√ìptimo:</strong> Si todos los costes son iguales</li>
                        <li>‚ùå <strong>Complejidad espacial alta:</strong> O(b^d) - guarda todos los nodos</li>
                        <li>‚ùå <strong>Complejidad temporal alta:</strong> O(b^d)</li>
                    </ul>
                </div>
            </div>

            <div class="code-block" style="margin-top: 1.5rem;">
<pre><code class="language-python">def bfs(grafo, inicio, meta):
    cola = deque([inicio])
    visitados = {inicio}
    padres = {inicio: None}

    while cola:
        actual = cola.popleft()

        if actual == meta:
            return reconstruir_camino(padres, meta)

        for vecino in grafo[actual]:
            if vecino not in visitados:
                visitados.add(vecino)
                padres[vecino] = actual
                cola.append(vecino)

    return None  # No hay soluci√≥n
</code></pre>
            </div>

            <h3 class="color-secondary mt-2">2. B√∫squeda en Profundidad (DFS - Depth-First Search)</h3>
            <div class="highlight-box secondary">
                <p><strong>Estrategia:</strong> Explora tan profundo como sea posible antes de retroceder.</p>
                <p><strong>Implementaci√≥n:</strong> Usa una pila LIFO (Last In, First Out)</p>

                <div class="highlight-box" style="margin-top: 1rem;">
                    <p class="tech-title">Caracter√≠sticas:</p>
                    <ul style="margin-left: 1.5rem; line-height: 1.6;">
                        <li>‚úÖ <strong>Complejidad espacial baja:</strong> O(b¬∑m) donde m es profundidad m√°xima</li>
                        <li>‚ùå <strong>No completo:</strong> Puede quedarse en bucles infinitos</li>
                        <li>‚ùå <strong>No √≥ptimo:</strong> Encuentra cualquier soluci√≥n, no necesariamente la mejor</li>
                        <li>‚ö†Ô∏è <strong>√ötil para:</strong> Espacios muy grandes donde BFS es inviable</li>
                    </ul>
                </div>
            </div>

            <h3 class="color-primary mt-2">3. B√∫squeda de Coste Uniforme (UCS - Uniform Cost Search)</h3>
            <div class="highlight-box">
                <p><strong>Estrategia:</strong> Expande el nodo con menor coste acumulado g(n) desde el inicio.</p>
                <p><strong>Implementaci√≥n:</strong> Usa una cola de prioridad (heap)</p>

                <div class="highlight-box secondary" style="margin-top: 1rem;">
                    <p class="tech-title">Caracter√≠sticas:</p>
                    <ul style="margin-left: 1.5rem; line-height: 1.6;">
                        <li>‚úÖ <strong>Completo:</strong> Encuentra soluci√≥n si existe</li>
                        <li>‚úÖ <strong>√ìptimo:</strong> Garantiza encontrar la ruta de menor coste</li>
                        <li>‚ö†Ô∏è <strong>Diferencia con BFS:</strong> BFS es UCS cuando todos los costes son iguales</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN 4: B√öSQUEDA INFORMADA (HEUR√çSTICA) -->
        <section class="section">
            <h2>Estrategias de B√∫squeda Informada</h2>
            <p>
                Las <strong>b√∫squedas informadas</strong> usan conocimiento espec√≠fico del problema mediante <strong>heur√≠sticas</strong>: funciones que estiman el coste desde un estado hasta la meta.
            </p>

            <h3 class="color-primary mt-2">Funci√≥n Heur√≠stica h(n)</h3>
            <div class="highlight-box">
                <p>
                    <strong>Definici√≥n:</strong> h(n) estima el coste desde el nodo n hasta el objetivo m√°s cercano.
                </p>
                <p>
                    <strong>Propiedad clave:</strong> Una heur√≠stica es <strong>admisible</strong> si nunca sobreestima el coste real (h(n) ‚â§ coste real).
                </p>

                <div class="highlight-box secondary" style="margin-top: 1rem;">
                    <p class="tech-title">Ejemplos de Heur√≠sticas:</p>
                    <p>‚Ä¢ <strong>Distancia Manhattan:</strong> |x‚ÇÅ-x‚ÇÇ| + |y‚ÇÅ-y‚ÇÇ| (navegaci√≥n en cuadr√≠cula)</p>
                    <p>‚Ä¢ <strong>Distancia Euclidiana:</strong> ‚àö[(x‚ÇÅ-x‚ÇÇ)¬≤ + (y‚ÇÅ-y‚ÇÇ)¬≤] (navegaci√≥n libre)</p>
                    <p>‚Ä¢ <strong>N√∫mero de piezas mal colocadas:</strong> 8-puzzle</p>
                </div>
            </div>

            <h3 class="color-secondary mt-2">4. Algoritmo A* (A-Star)</h3>
            <div class="highlight-box secondary">
                <p><strong>Estrategia:</strong> Combina el coste acumulado g(n) con la estimaci√≥n heur√≠stica h(n).</p>
                <p style="text-align: center; font-size: 1.3rem; font-weight: 700; color: var(--color-secondary); margin: 1rem 0;">
                    f(n) = g(n) + h(n)
                </p>
                <p style="text-align: center;">
                    <strong>g(n):</strong> Coste real desde inicio hasta n<br/>
                    <strong>h(n):</strong> Estimaci√≥n heur√≠stica desde n hasta meta<br/>
                    <strong>f(n):</strong> Estimaci√≥n del coste total de la soluci√≥n
                </p>

                <div class="highlight-box" style="margin-top: 1rem;">
                    <p class="tech-title">Caracter√≠sticas de A*:</p>
                    <ul style="margin-left: 1.5rem; line-height: 1.6;">
                        <li>‚úÖ <strong>Completo:</strong> Encuentra soluci√≥n si existe</li>
                        <li>‚úÖ <strong>√ìptimo:</strong> Si h(n) es admisible</li>
                        <li>‚úÖ <strong>Eficiente:</strong> Explora solo estados prometedores</li>
                        <li>üåü <strong>Est√°ndar de facto:</strong> Pathfinding en juegos, GPS, rob√≥tica</li>
                    </ul>
                </div>
            </div>

            <div class="code-block" style="margin-top: 1.5rem;">
<pre><code class="language-python">import heapq

def a_star(grafo, inicio, meta, heuristica):
    frontera = [(heuristica(inicio, meta), 0, inicio)]
    visitados = set()
    g_score = {inicio: 0}
    padres = {inicio: None}

    while frontera:
        f, g, actual = heapq.heappop(frontera)

        if actual in visitados:
            continue
        visitados.add(actual)

        if actual == meta:
            return reconstruir_camino(padres, meta), g

        for vecino, coste in grafo[actual]:
            nuevo_g = g + coste

            if vecino not in g_score or nuevo_g < g_score[vecino]:
                g_score[vecino] = nuevo_g
                f_score = nuevo_g + heuristica(vecino, meta)
                heapq.heappush(frontera, (f_score, nuevo_g, vecino))
                padres[vecino] = actual

    return None, float('inf')  # No hay soluci√≥n
</code></pre>
            </div>

            <h3 class="color-primary mt-2">5. B√∫squeda Greedy (Voraz)</h3>
            <div class="highlight-box">
                <p><strong>Estrategia:</strong> Expande el nodo que parece m√°s cercano a la meta seg√∫n h(n).</p>
                <p style="text-align: center; font-size: 1.3rem; font-weight: 700; color: var(--color-primary); margin: 1rem 0;">
                    f(n) = h(n)
                </p>

                <div class="highlight-box secondary" style="margin-top: 1rem;">
                    <p class="tech-title">Caracter√≠sticas:</p>
                    <ul style="margin-left: 1.5rem; line-height: 1.6;">
                        <li>‚úÖ <strong>Muy r√°pido:</strong> Menor complejidad que A*</li>
                        <li>‚ùå <strong>No √≥ptimo:</strong> Puede encontrar soluciones sub√≥ptimas</li>
                        <li>‚ö†Ô∏è <strong>Usar cuando:</strong> Velocidad > optimalidad</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN 5: TABLA COMPARATIVA -->
        <section class="section">
            <h2 class="text-center">Comparaci√≥n de Estrategias de B√∫squeda</h2>

            <div class="table-container">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Algoritmo</th>
                            <th>Completo</th>
                            <th>√ìptimo</th>
                            <th>Comp. Temporal</th>
                            <th>Comp. Espacial</th>
                            <th>Uso Principal</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>BFS</strong></td>
                            <td>‚úÖ S√≠</td>
                            <td>‚úÖ S√≠*</td>
                            <td>O(b^d)</td>
                            <td>O(b^d)</td>
                            <td>Costes uniformes, profundidad baja</td>
                        </tr>
                        <tr>
                            <td><strong>DFS</strong></td>
                            <td>‚ùå No**</td>
                            <td>‚ùå No</td>
                            <td>O(b^m)</td>
                            <td>O(b¬∑m)</td>
                            <td>Espacios grandes, soluci√≥n r√°pida</td>
                        </tr>
                        <tr>
                            <td><strong>UCS</strong></td>
                            <td>‚úÖ S√≠</td>
                            <td>‚úÖ S√≠</td>
                            <td>O(b^(C*/Œµ))</td>
                            <td>O(b^(C*/Œµ))</td>
                            <td>Costes variables, ruta √≥ptima</td>
                        </tr>
                        <tr>
                            <td><strong>Greedy</strong></td>
                            <td>‚ùå No</td>
                            <td>‚ùå No</td>
                            <td>O(b^m)</td>
                            <td>O(b^m)</td>
                            <td>Velocidad cr√≠tica</td>
                        </tr>
                        <tr>
                            <td><strong>A*</strong></td>
                            <td>‚úÖ S√≠</td>
                            <td>‚úÖ S√≠***</td>
                            <td>O(b^d)</td>
                            <td>O(b^d)</td>
                            <td>Pathfinding, navegaci√≥n</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="highlight-box mt-2">
                <p style="font-size: 0.95rem; line-height: 1.6;">
                    <strong>Notas:</strong><br/>
                    * BFS √≥ptimo si costes uniformes<br/>
                    ** DFS completo en grafos finitos con detecci√≥n de ciclos<br/>
                    *** A* √≥ptimo si heur√≠stica es admisible<br/>
                    <strong>Notaci√≥n:</strong> b=factor ramificaci√≥n, d=profundidad soluci√≥n, m=profundidad m√°xima, C*=coste √≥ptimo, Œµ=coste m√≠nimo arista
                </p>
            </div>
        </section>

        <!-- SECCI√ìN 6: APLICACIONES REALES -->
        <section class="section">
            <h2>Aplicaciones Reales de B√∫squeda en IA</h2>

            <div class="feature-grid">
                <div class="feature-card">
                    <h3 style="color: var(--color-primary);">üéÆ Videojuegos</h3>
                    <p><strong>Algoritmo:</strong> A* con heur√≠stica Manhattan</p>
                    <p><strong>Uso:</strong> Pathfinding de NPCs (Non-Player Characters). Juegos como StarCraft, League of Legends, The Sims usan A* para mover personajes evitando obst√°culos.</p>
                </div>

                <div class="feature-card secondary">
                    <h3 style="color: var(--color-secondary);">üó∫Ô∏è Navegaci√≥n GPS</h3>
                    <p><strong>Algoritmo:</strong> Variantes de A* (Contraction Hierarchies)</p>
                    <p><strong>Uso:</strong> Google Maps, Waze, Apple Maps calculan rutas √≥ptimas considerando tr√°fico, peajes y distancia.</p>
                </div>

                <div class="feature-card">
                    <h3 style="color: var(--color-primary);">ü§ñ Rob√≥tica</h3>
                    <p><strong>Algoritmo:</strong> RRT (Rapidly-exploring Random Trees) + A*</p>
                    <p><strong>Uso:</strong> Planificaci√≥n de trayectorias para brazos rob√≥ticos en f√°bricas, drones aut√≥nomos y veh√≠culos autoguiados (AGV).</p>
                </div>

                <div class="feature-card secondary">
                    <h3 style="color: var(--color-secondary);">‚ôüÔ∏è Juegos de Mesa</h3>
                    <p><strong>Algoritmo:</strong> Minimax con poda Alpha-Beta</p>
                    <p><strong>Uso:</strong> Motores de ajedrez (Stockfish), damas, Go (AlphaGo combina b√∫squeda con redes neuronales).</p>
                </div>
            </div>
        </section>

        <!-- SECCI√ìN 7: REGLA DE ORO -->
        <section class="section">
            <div class="comparison-grid">
                <div class="highlight-box">
                    <h3 class="text-center color-primary">üîµ B√∫squeda No Informada</h3>
                    <ul style="margin-left: 1.5rem; line-height: 1.7;">
                        <li><strong>Usar cuando:</strong> No hay heur√≠stica disponible</li>
                        <li><strong>BFS:</strong> Garant√≠a de optimalidad, memoria disponible</li>
                        <li><strong>DFS:</strong> Espacios grandes, memoria limitada</li>
                        <li><strong>UCS:</strong> Costes variables, ruta √≥ptima necesaria</li>
                    </ul>
                </div>

                <div class="highlight-box secondary">
                    <h3 class="text-center color-secondary">üü£ B√∫squeda Informada</h3>
                    <ul style="margin-left: 1.5rem; line-height: 1.7;">
                        <li><strong>Usar cuando:</strong> Existe heur√≠stica admisible</li>
                        <li><strong>A*:</strong> Est√°ndar para navegaci√≥n y pathfinding</li>
                        <li><strong>Greedy:</strong> Velocidad cr√≠tica, optimalidad secundaria</li>
                    </ul>
                </div>
            </div>

            <div class="curiosity-box mt-2">
                <h4>üí° Dato Curioso: AlphaGo y B√∫squeda Combinada</h4>
                <p>
                    <strong>AlphaGo</strong>, la IA de Google DeepMind que derrot√≥ al campe√≥n mundial de Go en 2016, combina b√∫squeda en √°rbol (variante de A*) con redes neuronales profundas. Eval√∫a <strong>280 millones de posiciones</strong> para decidir cada movimiento, reduciendo el espacio de b√∫squeda de 10¬π‚Å∑‚Å∞ estados posibles a una fracci√≥n manejable. Esta combinaci√≥n de b√∫squeda tradicional con machine learning representa el estado del arte en IA para juegos complejos.
                </p>
                <div class="highlight-box" style="margin-top: 1rem; text-align: center;">
                    <p>
                        üèÜ <strong>Impacto:</strong> Demostr√≥ que problemas considerados "demasiado complejos" para IA pod√≠an resolverse con estrategias de b√∫squeda avanzadas.
                    </p>
                </div>
            </div>

            <div class="highlight-box secondary mt-2" style="text-align: center;">
                <h4>üéØ Regla de Oro</h4>
                <p style="font-size: 1.125rem;">
                    "La mejor estrategia de b√∫squeda depende del problema. Analiza el espacio de estados, define una heur√≠stica admisible si es posible, y elige el algoritmo que equilibre <strong>optimalidad, eficiencia y recursos disponibles</strong>."
                </p>
            </div>
        </section>
    </main>

    <footer>
        <h3>iLERNA</h3>
        <p class="footer-course">Curso de Especializaci√≥n en Inteligencia Artificial y Big Data</p>
        <a href="https://www.ilerna.es/" target="_blank">www.ilerna.es</a>
        <p class="footer-info">Centro oficial de FP online y presencial. Ciclos formativos de Grado Medio y Grado Superior.</p>
        <p class="footer-info">Titulaciones 100% oficiales. ¬°Sin pruebas libres!</p>

        <div class="penguin">
            <span>üêß</span>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../js/lecciones.js"></script>
</body>
</html>
