<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementaciones en Python | Algoritmos de Grafos</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,500,600,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/index.css">
    <!-- Prism.js CSS - Tema One Dark -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <style>
        .code-section {
            margin: 2rem 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .code-header {
            background: linear-gradient(135deg, var(--azul-ilerna) 0%, var(--morado) 100%);
            color: white;
            padding: 1.5rem 2rem;
            border-bottom: 3px solid var(--azul-ilerna);
        }

        .code-header h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.875rem;
            color: white;
        }

        .code-header p {
            margin: 0;
            font-size: 1.125rem;
            opacity: 0.95;
        }

        .code-body {
            padding: 0;
        }

        .code-description {
            padding: 1.5rem 2rem;
            background: var(--fondo-azul);
            border-left: 4px solid var(--azul-ilerna);
            margin: 0;
        }

        .code-description h4 {
            color: var(--azul-ilerna);
            margin: 0 0 0.75rem 0;
            font-size: 1.125rem;
        }

        .code-description p {
            margin: 0 0 1rem 0;
            line-height: 1.8;
            color: var(--gris-texto);
            font-size: 1.125rem;
        }

        .code-description ul {
            margin: 0;
            padding-left: 1.5rem;
            color: var(--gris-texto);
            font-size: 1.125rem;
        }

        .code-description ul li {
            margin: 0.5rem 0;
            line-height: 1.6;
        }

        .complexity-badge {
            display: inline-block;
            background: var(--fondo-morado);
            color: var(--morado);
            padding: 0.35rem 0.75rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.95rem;
            margin-top: 0.5rem;
        }

        pre[class*="language-"] {
            margin: 0;
            border-radius: 0;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        code[class*="language-"] {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .line-numbers .line-numbers-rows {
            border-right-color: #444;
        }

        .algo-nav {
            position: sticky;
            top: 20px;
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .algo-nav h3 {
            margin: 0 0 1rem 0;
            color: var(--azul-ilerna);
            font-size: 1.875rem;
        }

        .algo-nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .algo-nav li {
            margin: 0.75rem 0;
        }

        .algo-nav a {
            color: var(--gris-texto);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            display: block;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 1.125rem;
        }

        .algo-nav a:hover {
            background: var(--fondo-azul);
            color: var(--azul-ilerna);
            transform: translateX(5px);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
            align-items: start;
        }

        @media (max-width: 968px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .algo-nav {
                position: static;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="logo-header">
            <img src="img/ilerna-logo.svg" alt="iLERNA Logo" class="ilerna-logo">
        </div>

        <header class="hero">
            <h1>üíª Implementaciones en Python</h1>
            <p class="subtitle">C√≥digo listo para usar de todos los algoritmos de grafos</p>
            <p class="hero-description">Implementaciones completas, optimizadas y comentadas de los algoritmos
                fundamentales de teor√≠a de grafos</p>
        </header>

        <section class="visualizations-section">
            <div class="content-grid">
                <!-- Navegaci√≥n lateral -->
                <div class="algo-nav">
                    <h3>Algoritmos</h3>
                    <ul>
                        <li><a href="#bfs">BFS</a></li>
                        <li><a href="#dfs">DFS</a></li>
                        <li><a href="#dijkstra">Dijkstra</a></li>
                        <li><a href="#bellman-ford">Bellman-Ford</a></li>
                        <li><a href="#floyd-warshall">Floyd-Warshall</a></li>
                        <li><a href="#astar">A*</a></li>
                        <li><a href="#prim">Prim (MST)</a></li>
                        <li><a href="#kruskal">Kruskal (MST)</a></li>
                        <li><a href="#tarjan">Tarjan SCC</a></li>
                        <li><a href="#ford-fulkerson">Ford-Fulkerson</a></li>
                    </ul>
                </div>

                <!-- Contenido principal -->
                <div>
                    <!-- BFS -->
                    <div class="code-section" id="bfs">
                        <div class="code-header">
                            <h3>üåä BFS - B√∫squeda en Anchura</h3>
                            <p>Explora el grafo nivel por nivel usando una cola FIFO</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>BFS recorre el grafo nivel por nivel, visitando todos los nodos a distancia k antes
                                    de visitar nodos a distancia k+1. Usa una cola FIFO para mantener el orden de
                                    exploraci√≥n.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Camino m√°s corto en grafos no ponderados,
                                        componentes conexas, niveles de √°rbol</li>
                                    <li><strong>Estructura de datos:</strong> Cola (FIFO)</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V + E) tiempo |
                                            O(V) espacio</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from collections import deque
from typing import List, Dict, Set

def bfs(graph: Dict[int, List[int]], start: int) -> List[int]:
    """
    Realiza b√∫squeda en anchura (BFS) desde un nodo inicial.

    Args:
        graph: Diccionario de listas de adyacencia {nodo: [vecinos]}
        start: Nodo inicial para comenzar la b√∫squeda

    Returns:
        Lista de nodos en el orden en que fueron visitados
    """
    visited: Set[int] = set()
    queue: deque = deque([start])
    order: List[int] = []

    visited.add(start)

    while queue:
        node = queue.popleft()
        order.append(node)

        # Explorar vecinos no visitados
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return order


def bfs_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]:
    """
    Encuentra el camino m√°s corto entre dos nodos usando BFS.

    Args:
        graph: Diccionario de listas de adyacencia
        start: Nodo inicial
        goal: Nodo objetivo

    Returns:
        Lista representando el camino m√°s corto, o lista vac√≠a si no hay camino
    """
    if start == goal:
        return [start]

    visited: Set[int] = {start}
    queue: deque = deque([(start, [start])])

    while queue:
        node, path = queue.popleft()

        for neighbor in graph.get(node, []):
            if neighbor == goal:
                return path + [neighbor]

            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return []  # No se encontr√≥ camino


# Ejemplo de uso
if __name__ == "__main__":
    # Crear un grafo de ejemplo
    graph = {
        0: [1, 2],
        1: [0, 3, 4],
        2: [0, 5],
        3: [1],
        4: [1, 5],
        5: [2, 4]
    }

    print("Orden de visita BFS desde nodo 0:")
    print(bfs(graph, 0))

    print("\nCamino m√°s corto de 0 a 5:")
    print(bfs_shortest_path(graph, 0, 5))
</code></pre>
                        </div>
                    </div>

                    <!-- DFS -->
                    <div class="code-section" id="dfs">
                        <div class="code-header">
                            <h3>üèä DFS - B√∫squeda en Profundidad</h3>
                            <p>Explora el grafo tan profundo como sea posible antes de retroceder</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>DFS explora cada rama del grafo hasta su m√°xima profundidad antes de retroceder.
                                    Puede implementarse recursivamente o con una pila expl√≠cita.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Detecci√≥n de ciclos, orden topol√≥gico,
                                        componentes conexas, resoluci√≥n de laberintos</li>
                                    <li><strong>Estructura de datos:</strong> Pila (LIFO) o recursi√≥n</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V + E) tiempo |
                                            O(V) espacio</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from typing import List, Dict, Set

def dfs_recursive(graph: Dict[int, List[int]], start: int,
                  visited: Set[int] = None, order: List[int] = None) -> List[int]:
    """
    Realiza DFS recursivo desde un nodo inicial.

    Args:
        graph: Diccionario de listas de adyacencia
        start: Nodo inicial
        visited: Conjunto de nodos visitados (para uso interno)
        order: Lista de orden de visita (para uso interno)

    Returns:
        Lista de nodos en el orden en que fueron visitados
    """
    if visited is None:
        visited = set()
    if order is None:
        order = []

    visited.add(start)
    order.append(start)

    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited, order)

    return order


def dfs_iterative(graph: Dict[int, List[int]], start: int) -> List[int]:
    """
    Realiza DFS iterativo usando una pila expl√≠cita.

    Args:
        graph: Diccionario de listas de adyacencia
        start: Nodo inicial

    Returns:
        Lista de nodos en el orden en que fueron visitados
    """
    visited: Set[int] = set()
    stack: List[int] = [start]
    order: List[int] = []

    while stack:
        node = stack.pop()

        if node not in visited:
            visited.add(node)
            order.append(node)

            # Agregar vecinos no visitados a la pila
            # Invertir para mantener orden consistente
            for neighbor in reversed(graph.get(node, [])):
                if neighbor not in visited:
                    stack.append(neighbor)

    return order


def detect_cycle(graph: Dict[int, List[int]]) -> bool:
    """
    Detecta si existe un ciclo en un grafo dirigido usando DFS.

    Args:
        graph: Diccionario de listas de adyacencia

    Returns:
        True si hay ciclo, False en caso contrario
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color: Dict[int, int] = {node: WHITE for node in graph}

    def has_cycle(node: int) -> bool:
        color[node] = GRAY

        for neighbor in graph.get(node, []):
            if color.get(neighbor, WHITE) == GRAY:
                return True  # Ciclo detectado (back edge)
            if color.get(neighbor, WHITE) == WHITE:
                if has_cycle(neighbor):
                    return True

        color[node] = BLACK
        return False

    # Verificar desde todos los nodos no visitados
    for node in graph:
        if color[node] == WHITE:
            if has_cycle(node):
                return True

    return False


# Ejemplo de uso
if __name__ == "__main__":
    graph = {
        0: [1, 2],
        1: [3],
        2: [3],
        3: [4],
        4: []
    }

    print("DFS Recursivo desde nodo 0:")
    print(dfs_recursive(graph, 0))

    print("\nDFS Iterativo desde nodo 0:")
    print(dfs_iterative(graph, 0))

    print("\n¬øTiene ciclo?", detect_cycle(graph))
</code></pre>
                        </div>
                    </div>

                    <!-- Dijkstra -->
                    <div class="code-section" id="dijkstra">
                        <div class="code-header">
                            <h3>üéØ Dijkstra - Camino M√°s Corto</h3>
                            <p>Algoritmo greedy para caminos m√°s cortos con pesos no negativos</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>Dijkstra encuentra el camino m√°s corto desde un nodo origen a todos los dem√°s nodos
                                    en un grafo con pesos no negativos, usando una cola de prioridad (heap).</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> GPS y navegaci√≥n, routing de redes, planificaci√≥n
                                        de rutas</li>
                                    <li><strong>Estructura de datos:</strong> Min-Heap (cola de prioridad)</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O((V + E) log V)
                                            tiempo | O(V) espacio</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">import heapq
from typing import Dict, List, Tuple
from collections import defaultdict

def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:
    """
    Algoritmo de Dijkstra para encontrar caminos m√°s cortos.

    Args:
        graph: Diccionario {nodo: [(vecino, peso), ...]}
        start: Nodo inicial

    Returns:
        Diccionario {nodo: distancia_m√≠nima_desde_start}
    """
    # Inicializar distancias con infinito
    distances: Dict[int, int] = {node: float('inf') for node in graph}
    distances[start] = 0

    # Cola de prioridad: (distancia, nodo)
    pq: List[Tuple[int, int]] = [(0, start)]
    visited: set = set()

    while pq:
        current_dist, node = heapq.heappop(pq)

        # Saltar si ya procesamos este nodo
        if node in visited:
            continue

        visited.add(node)

        # Si encontramos una distancia mayor, continuar
        if current_dist > distances[node]:
            continue

        # Relajar aristas
        for neighbor, weight in graph.get(node, []):
            distance = current_dist + weight

            # Si encontramos un camino m√°s corto
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances


def dijkstra_with_path(graph: Dict[int, List[Tuple[int, int]]],
                       start: int, goal: int) -> Tuple[int, List[int]]:
    """
    Dijkstra que retorna tanto la distancia como el camino completo.

    Args:
        graph: Diccionario {nodo: [(vecino, peso), ...]}
        start: Nodo inicial
        goal: Nodo objetivo

    Returns:
        Tupla (distancia, camino)
    """
    distances: Dict[int, int] = {node: float('inf') for node in graph}
    distances[start] = 0
    previous: Dict[int, int] = {}

    pq: List[Tuple[int, int]] = [(0, start)]

    while pq:
        current_dist, node = heapq.heappop(pq)

        if node == goal:
            break

        if current_dist > distances[node]:
            continue

        for neighbor, weight in graph.get(node, []):
            distance = current_dist + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = node
                heapq.heappush(pq, (distance, neighbor))

    # Reconstruir camino
    path: List[int] = []
    current = goal
    while current != start:
        path.append(current)
        if current not in previous:
            return (float('inf'), [])  # No hay camino
        current = previous[current]
    path.append(start)
    path.reverse()

    return (distances[goal], path)


# Ejemplo de uso
if __name__ == "__main__":
    # Grafo ponderado: {nodo: [(vecino, peso), ...]}
    graph = {
        0: [(1, 4), (2, 1)],
        1: [(3, 1)],
        2: [(1, 2), (3, 5)],
        3: [(4, 3)],
        4: []
    }

    print("Distancias desde nodo 0:")
    distances = dijkstra(graph, 0)
    for node, dist in sorted(distances.items()):
        print(f"  Nodo {node}: {dist}")

    print("\nCamino m√°s corto de 0 a 4:")
    dist, path = dijkstra_with_path(graph, 0, 4)
    print(f"  Distancia: {dist}")
    print(f"  Camino: {' ‚Üí '.join(map(str, path))}")
</code></pre>
                        </div>
                    </div>

                    <!-- Bellman-Ford -->
                    <div class="code-section" id="bellman-ford">
                        <div class="code-header">
                            <h3>‚ö° Bellman-Ford - Caminos con Pesos Negativos</h3>
                            <p>Encuentra caminos m√°s cortos y detecta ciclos negativos</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>Bellman-Ford calcula caminos m√°s cortos incluso con pesos negativos y puede detectar
                                    ciclos negativos. Relaja todas las aristas V-1 veces.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Routing con costos variables, detecci√≥n de
                                        arbitraje, sistemas con costos negativos</li>
                                    <li><strong>Ventaja:</strong> Funciona con pesos negativos</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V √ó E) tiempo |
                                            O(V) espacio</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from typing import Dict, List, Tuple, Optional

def bellman_ford(edges: List[Tuple[int, int, int]],
                 num_nodes: int, start: int) -> Tuple[Dict[int, float], bool]:
    """
    Algoritmo de Bellman-Ford para caminos m√°s cortos con pesos negativos.

    Args:
        edges: Lista de tuplas (origen, destino, peso)
        num_nodes: N√∫mero total de nodos
        start: Nodo inicial

    Returns:
        Tupla (distancias, tiene_ciclo_negativo)
    """
    # Inicializar distancias
    distances: Dict[int, float] = {i: float('inf') for i in range(num_nodes)}
    distances[start] = 0

    # Relajar aristas V-1 veces
    for _ in range(num_nodes - 1):
        for u, v, weight in edges:
            if distances[u] != float('inf') and distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight

    # Verificar ciclos negativos
    has_negative_cycle = False
    for u, v, weight in edges:
        if distances[u] != float('inf') and distances[u] + weight < distances[v]:
            has_negative_cycle = True
            break

    return (distances, has_negative_cycle)


def bellman_ford_with_path(edges: List[Tuple[int, int, int]],
                           num_nodes: int, start: int, goal: int) -> Optional[Tuple[float, List[int]]]:
    """
    Bellman-Ford que retorna camino completo.

    Args:
        edges: Lista de tuplas (origen, destino, peso)
        num_nodes: N√∫mero de nodos
        start: Nodo inicial
        goal: Nodo objetivo

    Returns:
        Tupla (distancia, camino) o None si hay ciclo negativo
    """
    distances: Dict[int, float] = {i: float('inf') for i in range(num_nodes)}
    distances[start] = 0
    predecessor: Dict[int, Optional[int]] = {i: None for i in range(num_nodes)}

    # Relajar aristas
    for _ in range(num_nodes - 1):
        for u, v, weight in edges:
            if distances[u] != float('inf') and distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight
                predecessor[v] = u

    # Detectar ciclo negativo
    for u, v, weight in edges:
        if distances[u] != float('inf') and distances[u] + weight < distances[v]:
            return None  # Ciclo negativo detectado

    # Reconstruir camino
    if distances[goal] == float('inf'):
        return None  # No hay camino

    path: List[int] = []
    current = goal
    while current is not None:
        path.append(current)
        current = predecessor[current]
    path.reverse()

    return (distances[goal], path)


# Ejemplo de uso
if __name__ == "__main__":
    # Lista de aristas: (origen, destino, peso)
    edges = [
        (0, 1, 4),
        (0, 2, 1),
        (2, 1, 2),
        (1, 3, 1),
        (2, 3, 5),
        (3, 4, 3)
    ]

    num_nodes = 5

    distances, has_cycle = bellman_ford(edges, num_nodes, 0)
    print("Distancias desde nodo 0:")
    for node, dist in sorted(distances.items()):
        print(f"  Nodo {node}: {dist}")
    print(f"¬øTiene ciclo negativo? {has_cycle}")

    result = bellman_ford_with_path(edges, num_nodes, 0, 4)
    if result:
        dist, path = result
        print(f"\nCamino de 0 a 4: {' ‚Üí '.join(map(str, path))} (distancia: {dist})")
</code></pre>
                        </div>
                    </div>

                    <!-- Contin√∫a con m√°s algoritmos... -->
                    <!-- Floyd-Warshall -->
                    <div class="code-section" id="floyd-warshall">
                        <div class="code-header">
                            <h3>üîÑ Floyd-Warshall - Todos los Pares</h3>
                            <p>Calcula el camino m√°s corto entre todos los pares de nodos</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>Algoritmo de programaci√≥n din√°mica que encuentra el camino m√°s corto entre todos los
                                    pares de nodos en un grafo ponderado (puede tener pesos negativos, pero no ciclos
                                    negativos).</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Matrices de distancias, clausura transitiva,
                                        ancho de banda m√°ximo</li>
                                    <li><strong>Estructura de datos:</strong> Matriz de adyacencia</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V¬≥) tiempo |
                                            O(V¬≤) espacio</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from typing import List

def floyd_warshall(graph: List[List[float]]) -> List[List[float]]:
    """
    Implementaci√≥n de Floyd-Warshall para encontrar caminos m√°s cortos entre todos los pares.
    
    Args:
        graph: Matriz de adyacencia NxN donde graph[i][j] es el peso de la arista i->j.
               Usar float('inf') si no hay arista.
               
    Returns:
        Matriz de distancias m√≠nimas
    """
    V = len(graph)
    # Crear una copia de la matriz de distancias
    dist = [row[:] for row in graph]
    
    # Algoritmo principal
    for k in range(V):
        for i in range(V):
            for j in range(V):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
                
    return dist

# Ejemplo de uso
if __name__ == "__main__":
    INF = float('inf')
    # Grafo de ejemplo
    graph = [
        [0, 5, INF, 10],
        [INF, 0, 3, INF],
        [INF, INF, 0, 1],
        [INF, INF, INF, 0]
    ]
    
    distances = floyd_warshall(graph)
    print("Matriz de distancias m√≠nimas:")
    for row in distances:
        print(row)
</code></pre>
                        </div>
                    </div>

                    <!-- A* Search -->
                    <div class="code-section" id="astar">
                        <div class="code-header">
                            <h3>‚≠ê A* Search - B√∫squeda Informada</h3>
                            <p>Encuentra el camino m√°s corto usando una heur√≠stica</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>A* es una extensi√≥n de Dijkstra que usa una funci√≥n heur√≠stica h(n) para estimar el
                                    costo restante hasta el objetivo. Prioriza nodos que parecen estar m√°s cerca de la
                                    meta.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Pathfinding en videojuegos, planificaci√≥n de
                                        robots, navegaci√≥n en mapas</li>
                                    <li><strong>Estructura de datos:</strong> Min-Heap (cola de prioridad)</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">Depende de la
                                            heur√≠stica (t√≠picamente O(E))</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">import heapq
from typing import Dict, List, Tuple, Callable

def a_star(graph: Dict[int, List[Tuple[int, int]]], 
           start: int, goal: int, 
           heuristic: Callable[[int, int], float]) -> List[int]:
    """
    Algoritmo A* para b√∫squeda de camino m√°s corto.
    
    Args:
        graph: Diccionario de adyacencia {nodo: [(vecino, peso)]}
        start: Nodo inicial
        goal: Nodo objetivo
        heuristic: Funci√≥n h(nodo_actual, nodo_objetivo) -> costo_estimado
        
    Returns:
        Lista de nodos representando el camino
    """
    open_set = []
    heapq.heappush(open_set, (0, start))
    
    came_from: Dict[int, int] = {}
    g_score: Dict[int, float] = {node: float('inf') for node in graph}
    g_score[start] = 0
    
    f_score: Dict[int, float] = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)
    
    while open_set:
        current = heapq.heappop(open_set)[1]
        
        if current == goal:
            # Reconstruir camino
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
            
        for neighbor, weight in graph.get(current, []):
            tentative_g = g_score[current] + weight
            
            if tentative_g < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                
                # En una implementaci√≥n optimizada, verificar√≠amos si ya est√° en open_set
                heapq.heappush(open_set, (f_score[neighbor], neighbor))
                
    return [] # No se encontr√≥ camino

# Ejemplo de uso
if __name__ == "__main__":
    # Heur√≠stica simple (distancia absoluta entre IDs para ejemplo)
    def h(node, goal):
        return abs(node - goal)
        
    graph = {
        0: [(1, 4), (2, 1)],
        1: [(3, 1)],
        2: [(1, 2), (3, 5)],
        3: [(4, 3)],
        4: []
    }
    
    path = a_star(graph, 0, 4, h)
    print(f"Camino A* de 0 a 4: {path}")
</code></pre>
                        </div>
                    </div>

                    <!-- Prim MST -->
                    <div class="code-section" id="prim">
                        <div class="code-header">
                            <h3>üå≤ Prim - √Årbol de Expansi√≥n M√≠nima</h3>
                            <p>Construye el MST creciendo desde un nodo inicial</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>El algoritmo de Prim encuentra un subconjunto de aristas que forman un √°rbol que
                                    incluye todos los v√©rtices, donde el peso total de todas las aristas del √°rbol es
                                    minimizado.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Dise√±o de redes, tendido de cables,
                                        clusterizaci√≥n</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(E log V) con cola
                                            de prioridad binaria</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">import heapq
from typing import Dict, List, Tuple

def prim_mst(graph: Dict[int, List[Tuple[int, int]]], start_node: int) -> List[Tuple[int, int, int]]:
    """
    Algoritmo de Prim para MST.
    
    Args:
        graph: Diccionario {nodo: [(vecino, peso)]}. El grafo debe ser conexo y no dirigido.
               (Para no dirigido, asegurar que si u->v est√°, v->u tambi√©n con mismo peso)
               
    Returns:
        Lista de aristas (u, v, peso) que forman el MST
    """
    mst = []
    visited = set([start_node])
    
    # Aristas candidatas: (peso, origen, destino)
    edges = [
        (weight, start_node, neighbor) 
        for neighbor, weight in graph.get(start_node, [])
    ]
    heapq.heapify(edges)
    
    while edges:
        weight, u, v = heapq.heappop(edges)
        
        if v not in visited:
            visited.add(v)
            mst.append((u, v, weight))
            
            for next_node, next_weight in graph.get(v, []):
                if next_node not in visited:
                    heapq.heappush(edges, (next_weight, v, next_node))
                    
    return mst

# Ejemplo
if __name__ == "__main__":
    # Grafo no dirigido
    graph = {
        0: [(1, 2), (3, 6)],
        1: [(0, 2), (2, 3), (3, 8), (4, 5)],
        2: [(1, 3), (4, 7)],
        3: [(0, 6), (1, 8)],
        4: [(1, 5), (2, 7)]
    }
    
    mst = prim_mst(graph, 0)
    print("Aristas en el MST (Prim):", mst)
    print("Peso total:", sum(w for u, v, w in mst))
</code></pre>
                        </div>
                    </div>

                    <!-- Kruskal MST -->
                    <div class="code-section" id="kruskal">
                        <div class="code-header">
                            <h3>üîó Kruskal - √Årbol de Expansi√≥n M√≠nima</h3>
                            <p>Construye el MST a√±adiendo las aristas m√°s ligeras que no forman ciclos</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>Kruskal ordena todas las aristas por peso y las a√±ade una a una si no forman un
                                    ciclo. Utiliza la estructura de datos Union-Find (Disjoint Set Union) para verificar
                                    ciclos eficientemente.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Redes LAN, aproximaci√≥n de problemas NP-hard
                                        (TSP)</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(E log E) o O(E
                                            log V)</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        
    def find(self, i):
        if self.parent[i] == i:
            return i
        self.parent[i] = self.find(self.parent[i]) # Path compression
        return self.parent[i]
        
    def union(self, i, j):
        root_i = self.find(i)
        root_j = self.find(j)
        if root_i != root_j:
            self.parent[root_i] = root_j
            return True
        return False

def kruskal_mst(num_nodes: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
    """
    Algoritmo de Kruskal para MST.
    
    Args:
        num_nodes: Cantidad total de nodos
        edges: Lista de (u, v, peso). Grafo no dirigido.
        
    Returns:
        Lista de aristas en el MST
    """
    # Ordenar aristas por peso
    sorted_edges = sorted(edges, key=lambda x: x[2])
    
    uf = UnionFind(num_nodes)
    mst = []
    
    for u, v, weight in sorted_edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            
    return mst

# Ejemplo
if __name__ == "__main__":
    edges = [
        (0, 1, 10), (0, 2, 6), (0, 3, 5),
        (1, 3, 15), (2, 3, 4)
    ]
    
    mst = kruskal_mst(4, edges)
    print("Aristas en el MST (Kruskal):", mst)
</code></pre>
                        </div>
                    </div>

                    <!-- Tarjan SCC -->
                    <div class="code-section" id="tarjan">
                        <div class="code-header">
                            <h3>üîç Tarjan - Componentes Fuertemente Conexas</h3>
                            <p>Encuentra SCCs en un grafo dirigido en una sola pasada DFS</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>El algoritmo de Tarjan encuentra las Componentes Fuertemente Conexas (SCC) de un
                                    grafo. Una SCC es un subgrafo maximal donde cada nodo es accesible desde cualquier
                                    otro nodo dentro del subgrafo.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> An√°lisis de redes sociales, dependencias de
                                        software, descomposici√≥n de grafos</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V + E)</span>
                                    </li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from typing import List, Dict

class TarjanSCC:
    def __init__(self, graph: Dict[int, List[int]]):
        self.graph = graph
        self.time = 0
        self.visited_time = {}
        self.low_link = {}
        self.on_stack = set()
        self.stack = []
        self.sccs = []
        
    def find_sccs(self) -> List[List[int]]:
        for node in self.graph:
            if node not in self.visited_time:
                self._dfs(node)
        return self.sccs
        
    def _dfs(self, u: int):
        self.visited_time[u] = self.low_link[u] = self.time
        self.time += 1
        self.stack.append(u)
        self.on_stack.add(u)
        
        for v in self.graph.get(u, []):
            if v not in self.visited_time:
                self._dfs(v)
                self.low_link[u] = min(self.low_link[u], self.low_link[v])
            elif v in self.on_stack:
                self.low_link[u] = min(self.low_link[u], self.visited_time[v])
        
        # Si u es nodo ra√≠z de una SCC
        if self.low_link[u] == self.visited_time[u]:
            component = []
            while True:
                node = self.stack.pop()
                self.on_stack.remove(node)
                component.append(node)
                if node == u:
                    break
            self.sccs.append(component)

# Ejemplo
if __name__ == "__main__":
    graph = {
        0: [1],
        1: [2],
        2: [0, 3],
        3: [4],
        4: [5, 3],
        5: []
    }
    
    tarjan = TarjanSCC(graph)
    print("Componentes Fuertemente Conexas:", tarjan.find_sccs())
</code></pre>
                        </div>
                    </div>

                    <!-- Ford-Fulkerson -->
                    <div class="code-section" id="ford-fulkerson">
                        <div class="code-header">
                            <h3>üåä Ford-Fulkerson - Flujo M√°ximo</h3>
                            <p>Calcula el flujo m√°ximo en una red de flujo (implementaci√≥n Edmonds-Karp con BFS)</p>
                        </div>
                        <div class="code-body">
                            <div class="code-description">
                                <h4>Descripci√≥n del Algoritmo</h4>
                                <p>Este algoritmo calcula el flujo m√°ximo posible desde una fuente a un sumidero en un
                                    grafo dirigido y ponderado. Esta implementaci√≥n usa BFS para encontrar caminos de
                                    aumento (Edmonds-Karp), garantizando terminaci√≥n.</p>
                                <ul>
                                    <li><strong>Aplicaciones:</strong> Redes de tuber√≠as, tr√°fico, matching bipartito,
                                        asignaci√≥n de tareas</li>
                                    <li><strong>Complejidad:</strong> <span class="complexity-badge">O(V E¬≤)</span></li>
                                </ul>
                            </div>
                            <pre class="line-numbers"><code class="language-python">from collections import deque
from typing import List

class FordFulkerson:
    def __init__(self, graph: List[List[int]]):
        self.graph = graph # Matriz de adyacencia (o capacidades residuales)
        self.ROW = len(graph)
        
    def bfs(self, s: int, t: int, parent: List[int]) -> bool:
        visited = [False] * self.ROW
        queue = deque([s])
        visited[s] = True
        parent[s] = -1
        
        while queue:
            u = queue.popleft()
            for v, capacity in enumerate(self.graph[u]):
                if not visited[v] and capacity > 0:
                    queue.append(v)
                    visited[v] = True
                    parent[v] = u
                    if v == t:
                        return True
        return False
            
    def edmonds_karp(self, source: int, sink: int) -> int:
        parent = [-1] * self.ROW
        max_flow = 0
        
        # Mientras exista un camino de aumento
        while self.bfs(source, sink, parent):
            path_flow = float("Inf")
            s = sink
            
            # Encontrar el cuello de botella del camino
            while s != source:
                path_flow = min(path_flow, self.graph[parent[s]][s])
                s = parent[s]
                
            max_flow += path_flow
            
            # Actualizar capacidades residuales
            v = sink
            while v != source:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]
                
        return max_flow

# Ejemplo
if __name__ == "__main__":
    # Matriz de capacidades
    # Nodos: 0, 1, 2, 3, 4, 5
    graph = [
        [0, 16, 13, 0, 0, 0],
        [0, 0, 10, 12, 0, 0],
        [0, 4, 0, 0, 14, 0],
        [0, 0, 9, 0, 0, 20],
        [0, 0, 0, 7, 0, 4],
        [0, 0, 0, 0, 0, 0]
    ]
    
    ff = FordFulkerson(graph)
    print("Flujo M√°ximo: %d" % ff.edmonds_karp(0, 5))
</code></pre>
                        </div>
                    </div>

                </div>
            </div>
        </section>

        <footer>
            <div class="penguin">üêß</div>

            <div style="margin-bottom: 1.5rem;">
                <h3>iLERNA</h3>
                <p class="course-title">Curso de Especializaci√≥n en Inteligencia Artificial y Big Data</p>
                <a href="https://www.ilerna.es/" target="_blank">www.ilerna.es</a>
            </div>

            <p class="info-text">Centro oficial de FP online y presencial. Ciclos formativos de Grado Medio y Grado
                Superior.</p>
            <p class="info-text">¬°Titulaciones 100% oficiales. Sin pruebas libres!</p>
        </footer>
    </div>

    <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <!-- Custom JavaScript -->
    <script src="js/implementaciones.js"></script>
</body>

</html>